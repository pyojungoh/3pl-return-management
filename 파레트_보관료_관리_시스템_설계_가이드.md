# 파레트 보관료 관리 시스템 설계 가이드

## 📋 목차
1. [시스템 개요](#시스템-개요)
2. [핵심 요구사항](#핵심-요구사항)
3. [데이터베이스 스키마](#데이터베이스-스키마)
4. [API 엔드포인트 설계](#api-엔드포인트-설계)
5. [보관료 계산 로직](#보관료-계산-로직)
6. [월별 정산 로직](#월별-정산-로직)
7. [프론트엔드 UI 설계](#프론트엔드-ui-설계)
8. [모바일 QR 스캔 설계](#모바일-qr-스캔-설계)
9. [권한 관리](#권한-관리)
10. [모듈 구조](#모듈-구조)
11. [개발 순서](#개발-순서)
12. [데이터 마이그레이션](#데이터-마이그레이션)

---

## 시스템 개요

### 목적
- 파레트별 보관일수를 자동으로 계산하여 월별 보관료를 정산
- 화주사별 실시간 보관 상태 조회 및 월별 정산 내역 확인
- 입고/보관종료 처리의 자동화 및 정확한 보관료 계산

### 주요 기능
1. **파레트 입고**: 모바일 또는 수기 입력 (대량 입력 지원)
2. **파레트 보관종료**: QR 코드 스캔으로 자동 처리
3. **보관료 자동 계산**: 입고일 ~ 보관종료일(또는 현재일) 기간 계산
4. **월별 정산**: 매월 1일~말일 보관일수 계산 → 다음달 초 청구
5. **실시간 현황 조회**: 화주사별 보관 상태 실시간 확인

---

## 핵심 요구사항

### 1. 파레트 ID 규칙
- **형식**: `년월일_001` (예: `251226_001`, `251226_002`)
- **중복 방지**: 같은 날짜에 입고되는 파레트는 `_001`, `_002` 형식으로 자동 증가
- **생성 규칙**: 입고 시 자동 생성 또는 수동 입력 가능

### 2. 파레트 상태
- **입고**: 파레트 입고 처리
- **보관종료**: QR 스캔 또는 수동으로 보관종료 처리
- **서비스**: 보관료 면제 파레트 (보관료 0원, 입고/보관종료는 표시)

### 3. 보관료 계산 방식
- **화주사별 월 보관료 설정**: 각 화주사마다 다른 월 보관료 설정 가능
- **일 보관료 계산**: `일 보관료 = 월 보관료 ÷ 30.44`
- **보관일수 계산**: `입고일 ~ 보관종료일(또는 현재일)` 기간 계산
- **최종 보관료**: `일 보관료 × 보관일수` (백원 단위 올림)

### 4. 월별 정산
- **정산 기간**: 매월 1일 00:00 ~ 말일 23:59:59
- **정산 시점**: 다음달 초 (예: 1월 정산은 2월 초에 생성)
- **정산 범위**: 해당 월에 보관했던 모든 파레트
- **보관일수 계산**:
  - 보관종료된 파레트: 입고일 ~ 보관종료일 (단, 보관종료일이 해당 월 내에 있어야 함)
  - 보관중인 파레트: 입고일 ~ 해당 월 말일
  - 서비스 파레트: 보관료 0원 (보관일수는 계산하되 보관료는 0원)

### 5. 서비스 파레트 처리
- **보관료**: 0원
- **표시**: 입고일, 보관종료일은 정상적으로 표시
- **정산**: 보관일수는 계산되지만 보관료는 0원으로 처리

---

## 데이터베이스 스키마

### 1. `pallets` 테이블 (파레트 기본 정보)

```sql
CREATE TABLE IF NOT EXISTS pallets (
    id INTEGER PRIMARY KEY AUTOINCREMENT,  -- PostgreSQL: SERIAL PRIMARY KEY
    pallet_id TEXT NOT NULL UNIQUE,        -- 파레트 ID (예: 251226_001)
    company_name TEXT NOT NULL,            -- 화주사명
    product_name TEXT,                     -- 품목명
    status TEXT NOT NULL DEFAULT '입고됨', -- 상태: 입고됨, 보관종료, 서비스
    in_date DATE NOT NULL,                 -- 입고일
    out_date DATE,                         -- 보관종료일 (NULL이면 보관중)
    storage_location TEXT,                  -- 보관 위치
    quantity INTEGER DEFAULT 1,             -- 수량
    is_service INTEGER DEFAULT 0,           -- 서비스 여부 (0: 일반, 1: 서비스)
    notes TEXT,                             -- 비고
    created_by TEXT,                        -- 생성자 (username)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_pallets_company ON pallets(company_name);
CREATE INDEX IF NOT EXISTS idx_pallets_status ON pallets(status);
CREATE INDEX IF NOT EXISTS idx_pallets_in_date ON pallets(in_date);
CREATE INDEX IF NOT EXISTS idx_pallets_out_date ON pallets(out_date);
```

### 2. `pallet_fees` 테이블 (화주사별 보관료 설정)

```sql
CREATE TABLE IF NOT EXISTS pallet_fees (
    id INTEGER PRIMARY KEY AUTOINCREMENT,  -- PostgreSQL: SERIAL PRIMARY KEY
    company_name TEXT NOT NULL UNIQUE,      -- 화주사명
    monthly_fee INTEGER NOT NULL,           -- 월 보관료 (원)
    daily_fee REAL NOT NULL,                -- 일일 보관료 (자동 계산: monthly_fee / 30.44)
    effective_from DATE NOT NULL,            -- 적용 시작일
    notes TEXT,                              -- 비고
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_pallet_fees_company ON pallet_fees(company_name);
```

### 3. `pallet_transactions` 테이블 (입고/출고 이력)

```sql
CREATE TABLE IF NOT EXISTS pallet_transactions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,  -- PostgreSQL: SERIAL PRIMARY KEY
    pallet_id TEXT NOT NULL,                -- 파레트 ID
    transaction_type TEXT NOT NULL,         -- 입고, 보관종료, 서비스변경
    quantity INTEGER DEFAULT 1,              -- 수량
    transaction_date TIMESTAMP NOT NULL,     -- 처리일시
    processed_by TEXT,                       -- 처리자 (username)
    notes TEXT,                              -- 비고
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (pallet_id) REFERENCES pallets(pallet_id) ON DELETE CASCADE
);

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_transactions_pallet ON pallet_transactions(pallet_id);
CREATE INDEX IF NOT EXISTS idx_transactions_date ON pallet_transactions(transaction_date);
```

### 4. `pallet_monthly_settlements` 테이블 (월별 정산 내역)

```sql
CREATE TABLE IF NOT EXISTS pallet_monthly_settlements (
    id INTEGER PRIMARY KEY AUTOINCREMENT,  -- PostgreSQL: SERIAL PRIMARY KEY
    company_name TEXT NOT NULL,            -- 화주사명
    settlement_month TEXT NOT NULL,        -- 정산월 (YYYY-MM 형식, 예: 2025-01)
    total_pallets INTEGER DEFAULT 0,        -- 총 파레트 수
    total_storage_days INTEGER DEFAULT 0,   -- 총 보관일수
    total_fee INTEGER DEFAULT 0,           -- 총 보관료 (원)
    status TEXT DEFAULT '대기',            -- 상태: 대기, 확정, 청구완료
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(company_name, settlement_month)
);

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_settlements_company ON pallet_monthly_settlements(company_name);
CREATE INDEX IF NOT EXISTS idx_settlements_month ON pallet_monthly_settlements(settlement_month);
```

### 5. `pallet_fee_calculations` 테이블 (파레트별 보관료 상세)

```sql
CREATE TABLE IF NOT EXISTS pallet_fee_calculations (
    id INTEGER PRIMARY KEY AUTOINCREMENT,  -- PostgreSQL: SERIAL PRIMARY KEY
    pallet_id TEXT NOT NULL,                -- 파레트 ID
    settlement_month TEXT NOT NULL,         -- 정산월 (YYYY-MM)
    storage_days INTEGER NOT NULL,          -- 보관일수
    daily_fee REAL NOT NULL,                -- 일일 보관료
    calculated_fee REAL NOT NULL,           -- 계산된 보관료 (일일 보관료 × 보관일수)
    rounded_fee INTEGER NOT NULL,           -- 백원 단위 올림된 보관료
    is_service INTEGER DEFAULT 0,            -- 서비스 여부
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (pallet_id) REFERENCES pallets(pallet_id) ON DELETE CASCADE
);

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_calculations_pallet ON pallet_fee_calculations(pallet_id);
CREATE INDEX IF NOT EXISTS idx_calculations_month ON pallet_fee_calculations(settlement_month);
```

---

## API 엔드포인트 설계

### 모듈 구조
```
api/
  └── pallets/              # 새 모듈 (독립적)
      ├── __init__.py
      ├── routes.py         # API 엔드포인트
      └── models.py         # 데이터베이스 함수
```

### 접두사 규칙
- 모든 함수명, ID, 클래스명에 `pal-` 접두사 사용
- 예: `pal-pallet-list`, `pal-fee-calculator`, `palInbound()`, `palLoadPallets()`

### 1. 파레트 관리 API

#### 1.1 파레트 입고 (단일)
```
POST /api/pallets/inbound
Request Body:
{
  "pallet_id": "251226_001",      // 선택사항 (없으면 자동 생성)
  "company_name": "화주사명",
  "product_name": "품목명",
  "in_date": "2025-12-26",
  "storage_location": "A-01",
  "quantity": 1,
  "is_service": false,
  "notes": "비고"
}

Response:
{
  "success": true,
  "message": "파레트 입고 완료",
  "data": {
    "pallet_id": "251226_001",
    "status": "입고됨",
    "in_date": "2025-12-26"
  }
}
```

#### 1.2 파레트 입고 (대량)
```
POST /api/pallets/inbound/bulk
Request Body:
{
  "pallets": [
    {
      "pallet_id": "251226_001",
      "company_name": "화주사명",
      "product_name": "품목명",
      "in_date": "2025-12-26",
      "storage_location": "A-01",
      "quantity": 1,
      "is_service": false
    },
    // ... 더 많은 파레트
  ]
}

Response:
{
  "success": true,
  "message": "10개 파레트 입고 완료",
  "data": {
    "total": 10,
    "success": 10,
    "failed": 0
  }
}
```

#### 1.3 파레트 보관종료 (QR 스캔)
```
POST /api/pallets/outbound
Request Body:
{
  "pallet_id": "251226_001",      // QR 스캔으로 얻은 ID
  "out_date": "2025-12-31",       // 선택사항 (없으면 현재일)
  "notes": "비고"
}

Response:
{
  "success": true,
  "message": "파레트 보관종료 완료",
  "data": {
    "pallet_id": "251226_001",
    "status": "보관종료",
    "out_date": "2025-12-31",
    "storage_days": 5,
    "calculated_fee": 5000
  }
}
```

#### 1.4 파레트 목록 조회
```
GET /api/pallets/list?company={company_name}&status={status}&month={YYYY-MM}&role={role}

Query Parameters:
- company: 화주사명 (화주사인 경우 필수)
- status: 상태 필터 (입고됨, 보관종료, 서비스, 전체)
- month: 월 필터 (YYYY-MM 형식)
- role: 권한 (관리자, 화주사)

Response:
{
  "success": true,
  "data": [
    {
      "pallet_id": "251226_001",
      "company_name": "화주사명",
      "product_name": "품목명",
      "status": "입고됨",
      "in_date": "2025-12-26",
      "out_date": null,
      "storage_days": 5,
      "current_fee": 5000,
      "is_service": false
    }
  ],
  "count": 10
}
```

#### 1.5 파레트 상세 조회
```
GET /api/pallets/{pallet_id}

Response:
{
  "success": true,
  "data": {
    "pallet_id": "251226_001",
    "company_name": "화주사명",
    "product_name": "품목명",
    "status": "입고됨",
    "in_date": "2025-12-26",
    "out_date": null,
    "storage_location": "A-01",
    "quantity": 1,
    "is_service": false,
    "storage_days": 5,
    "current_fee": 5000,
    "transactions": [
      {
        "transaction_type": "입고",
        "transaction_date": "2025-12-26T10:00:00",
        "processed_by": "admin"
      }
    ]
  }
}
```

#### 1.6 파레트 정보 수정
```
PUT /api/pallets/{pallet_id}
Request Body:
{
  "product_name": "수정된 품목명",
  "storage_location": "B-02",
  "is_service": true,
  "notes": "수정된 비고"
}

Response:
{
  "success": true,
  "message": "파레트 정보 수정 완료"
}
```

### 2. 보관료 관리 API

#### 2.1 화주사별 보관료 설정 조회
```
GET /api/pallets/fees?company={company_name}

Response:
{
  "success": true,
  "data": {
    "company_name": "화주사명",
    "monthly_fee": 16000,
    "daily_fee": 526,
    "effective_from": "2025-01-01"
  }
}
```

#### 2.2 화주사별 보관료 설정 생성/수정
```
POST /api/pallets/fees
Request Body:
{
  "company_name": "화주사명",
  "monthly_fee": 16000,
  "effective_from": "2025-01-01",
  "notes": "비고"
}

Response:
{
  "success": true,
  "message": "보관료 설정 완료",
  "data": {
    "company_name": "화주사명",
    "monthly_fee": 16000,
    "daily_fee": 526  // 자동 계산
  }
}
```

#### 2.3 보관료 실시간 계산
```
GET /api/pallets/fees/calculate?pallet_id={pallet_id}&as_of_date={YYYY-MM-DD}

Query Parameters:
- pallet_id: 파레트 ID
- as_of_date: 계산 기준일 (선택사항, 없으면 현재일)

Response:
{
  "success": true,
  "data": {
    "pallet_id": "251226_001",
    "storage_days": 5,
    "daily_fee": 526,
    "calculated_fee": 2630,
    "rounded_fee": 2700  // 백원 단위 올림
  }
}
```

### 3. 월별 정산 API

#### 3.1 월별 정산 내역 조회
```
GET /api/pallets/settlements?company={company_name}&month={YYYY-MM}&role={role}

Query Parameters:
- company: 화주사명 (화주사인 경우 필수)
- month: 정산월 (YYYY-MM 형식)
- role: 권한 (관리자, 화주사)

Response:
{
  "success": true,
  "data": [
    {
      "id": 1,
      "company_name": "화주사명",
      "settlement_month": "2025-01",
      "total_pallets": 10,
      "total_storage_days": 150,
      "total_fee": 78900,
      "status": "확정"
    }
  ]
}
```

#### 3.2 월별 정산 생성
```
POST /api/pallets/settlements/generate
Request Body:
{
  "settlement_month": "2025-01",  // 선택사항 (없으면 전월)
  "company_name": "화주사명"       // 선택사항 (없으면 전체 화주사)
}

Response:
{
  "success": true,
  "message": "정산 생성 완료",
  "data": {
    "settlement_month": "2025-01",
    "total_companies": 5,
    "total_pallets": 50,
    "total_fee": 500000
  }
}
```

#### 3.3 특정 월 정산 상세
```
GET /api/pallets/settlements/{id}/detail

Response:
{
  "success": true,
  "data": {
    "id": 1,
    "company_name": "화주사명",
    "settlement_month": "2025-01",
    "total_pallets": 10,
    "total_storage_days": 150,
    "total_fee": 78900,
    "status": "확정",
    "pallets": [
      {
        "pallet_id": "251226_001",
        "product_name": "품목명",
        "in_date": "2025-01-05",
        "out_date": "2025-01-20",
        "storage_days": 15,
        "daily_fee": 526,
        "rounded_fee": 7900,
        "is_service": false
      }
    ]
  }
}
```

#### 3.4 정산 확정
```
PUT /api/pallets/settlements/{id}/confirm

Response:
{
  "success": true,
  "message": "정산 확정 완료"
}
```

### 4. QR 코드 API

#### 4.1 QR 코드 생성
```
GET /api/pallets/qr/{pallet_id}

Response:
{
  "success": true,
  "data": {
    "pallet_id": "251226_001",
    "qr_code_url": "data:image/png;base64,...",
    "qr_code_data": "251226_001"
  }
}
```

#### 4.2 QR 코드 스캔 처리
```
POST /api/pallets/qr/scan
Request Body:
{
  "qr_data": "251226_001"  // QR 스캔으로 얻은 데이터
}

Response:
{
  "success": true,
  "data": {
    "pallet_id": "251226_001",
    "company_name": "화주사명",
    "product_name": "품목명",
    "status": "입고됨",
    "in_date": "2025-12-26"
  }
}
```

---

## 보관료 계산 로직

### 1. 일일 보관료 계산
```python
def calculate_daily_fee(company_name: str, as_of_date: date = None) -> float:
    """
    화주사별 일일 보관료 계산
    
    Args:
        company_name: 화주사명
        as_of_date: 기준일 (선택사항, 없으면 현재일)
    
    Returns:
        일일 보관료 (float)
    """
    # pallet_fees 테이블에서 화주사별 월 보관료 조회
    monthly_fee = get_monthly_fee(company_name, as_of_date)
    
    # 일일 보관료 = 월 보관료 ÷ 30.44
    daily_fee = monthly_fee / 30.44
    
    return round(daily_fee, 2)
```

### 2. 보관일수 계산
```python
def calculate_storage_days(in_date: date, out_date: date = None, 
                          as_of_date: date = None) -> int:
    """
    보관일수 계산
    
    Args:
        in_date: 입고일
        out_date: 보관종료일 (None이면 보관중)
        as_of_date: 기준일 (선택사항, 없으면 현재일)
    
    Returns:
        보관일수 (int)
    """
    if as_of_date is None:
        as_of_date = date.today()
    
    # 보관종료일이 있으면 보관종료일까지, 없으면 기준일까지
    end_date = out_date if out_date else as_of_date
    
    # 보관일수 = (종료일 - 입고일) + 1 (입고일 포함)
    storage_days = (end_date - in_date).days + 1
    
    return max(0, storage_days)  # 음수 방지
```

### 3. 보관료 계산 (백원 단위 올림)
```python
def calculate_fee(company_name: str, in_date: date, out_date: date = None,
                 is_service: bool = False, as_of_date: date = None) -> int:
    """
    보관료 계산 (백원 단위 올림)
    
    Args:
        company_name: 화주사명
        in_date: 입고일
        out_date: 보관종료일 (None이면 보관중)
        is_service: 서비스 여부
        as_of_date: 기준일 (선택사항, 없으면 현재일)
    
    Returns:
        보관료 (원, int, 백원 단위 올림)
    """
    # 서비스 파레트는 보관료 0원
    if is_service:
        return 0
    
    # 일일 보관료 조회
    daily_fee = calculate_daily_fee(company_name, as_of_date)
    
    # 보관일수 계산
    storage_days = calculate_storage_days(in_date, out_date, as_of_date)
    
    # 계산된 보관료 = 일일 보관료 × 보관일수
    calculated_fee = daily_fee * storage_days
    
    # 백원 단위 올림: Math.ceil(calculated_fee / 100) × 100
    rounded_fee = math.ceil(calculated_fee / 100) * 100
    
    return int(rounded_fee)
```

---

## 월별 정산 로직

### 1. 정산 월 계산
```python
def get_settlement_month(target_date: date = None) -> str:
    """
    정산월 계산 (YYYY-MM 형식)
    
    Args:
        target_date: 기준일 (선택사항, 없으면 현재일)
    
    Returns:
        정산월 (str, 예: "2025-01")
    """
    if target_date is None:
        target_date = date.today()
    
    # 다음달 초에 전월 정산 생성
    # 예: 2월 1일이면 1월 정산 생성
    settlement_month = target_date.replace(day=1) - timedelta(days=1)
    
    return settlement_month.strftime("%Y-%m")
```

### 2. 월별 정산 생성
```python
def generate_monthly_settlement(settlement_month: str, 
                                company_name: str = None) -> dict:
    """
    월별 정산 생성
    
    Args:
        settlement_month: 정산월 (YYYY-MM 형식)
        company_name: 화주사명 (None이면 전체 화주사)
    
    Returns:
        정산 결과 (dict)
    """
    # 정산월의 시작일과 종료일 계산
    year, month = map(int, settlement_month.split('-'))
    start_date = date(year, month, 1)
    
    # 다음 달 1일 - 1일 = 이번 달 말일
    if month == 12:
        end_date = date(year + 1, 1, 1) - timedelta(days=1)
    else:
        end_date = date(year, month + 1, 1) - timedelta(days=1)
    
    # 해당 월에 보관했던 모든 파레트 조회
    pallets = get_pallets_for_settlement(
        company_name=company_name,
        start_date=start_date,
        end_date=end_date
    )
    
    # 화주사별로 그룹화
    company_settlements = {}
    
    for pallet in pallets:
        company = pallet['company_name']
        
        if company not in company_settlements:
            company_settlements[company] = {
                'total_pallets': 0,
                'total_storage_days': 0,
                'total_fee': 0,
                'pallets': []
            }
        
        # 보관일수 계산 (해당 월 내에서만)
        in_date = pallet['in_date']
        out_date = pallet['out_date']
        
        # 보관 시작일: 입고일과 정산월 시작일 중 늦은 날
        storage_start = max(in_date, start_date)
        
        # 보관 종료일: 보관종료일과 정산월 종료일 중 이른 날
        if out_date:
            storage_end = min(out_date, end_date)
        else:
            storage_end = end_date
        
        # 보관일수 계산
        storage_days = (storage_end - storage_start).days + 1
        
        # 보관료 계산
        if pallet['is_service']:
            fee = 0
        else:
            daily_fee = calculate_daily_fee(company, storage_start)
            calculated_fee = daily_fee * storage_days
            fee = math.ceil(calculated_fee / 100) * 100
        
        # 정산 데이터에 추가
        company_settlements[company]['total_pallets'] += 1
        company_settlements[company]['total_storage_days'] += storage_days
        company_settlements[company]['total_fee'] += fee
        company_settlements[company]['pallets'].append({
            'pallet_id': pallet['pallet_id'],
            'product_name': pallet['product_name'],
            'in_date': pallet['in_date'],
            'out_date': pallet['out_date'],
            'storage_days': storage_days,
            'rounded_fee': fee,
            'is_service': pallet['is_service']
        })
    
    # 데이터베이스에 저장
    for company, settlement in company_settlements.items():
        save_settlement(
            company_name=company,
            settlement_month=settlement_month,
            total_pallets=settlement['total_pallets'],
            total_storage_days=settlement['total_storage_days'],
            total_fee=settlement['total_fee'],
            status='대기'
        )
        
        # 파레트별 보관료 상세 저장
        for pallet in settlement['pallets']:
            save_fee_calculation(
                pallet_id=pallet['pallet_id'],
                settlement_month=settlement_month,
                storage_days=pallet['storage_days'],
                daily_fee=calculate_daily_fee(company),
                calculated_fee=pallet['rounded_fee'],
                rounded_fee=pallet['rounded_fee'],
                is_service=pallet['is_service']
            )
    
    return company_settlements
```

### 3. 정산 조회 (월별 필터링)
```python
def get_settlements(company_name: str = None, 
                   settlement_month: str = None,
                   role: str = '화주사') -> list:
    """
    월별 정산 조회
    
    Args:
        company_name: 화주사명 (화주사인 경우 필수)
        settlement_month: 정산월 (YYYY-MM 형식, 선택사항)
        role: 권한 (관리자, 화주사)
    
    Returns:
        정산 내역 리스트
    """
    query = "SELECT * FROM pallet_monthly_settlements WHERE 1=1"
    params = []
    
    # 화주사 필터링
    if role != '관리자' and company_name:
        query += " AND company_name = ?"
        params.append(company_name)
    elif company_name:
        query += " AND company_name = ?"
        params.append(company_name)
    
    # 월 필터링
    if settlement_month:
        query += " AND settlement_month = ?"
        params.append(settlement_month)
    
    query += " ORDER BY settlement_month DESC, company_name"
    
    # 데이터베이스 조회
    return execute_query(query, params)
```

---

## 프론트엔드 UI 설계

### 1. 메뉴 구조

```
📦 파레트 관리 (새 메뉴)
  ├── 파레트 입고
  │   ├── 단일 입고
  │   └── 대량 입고 (CSV/Excel)
  ├── 파레트 출고 (QR 스캔)
  ├── 파레트 현황
  │   ├── 전체 현황 (관리자)
  │   └── 내 파레트 (화주사)
  ├── 보관료 설정 (관리자)
  └── 월별 정산
      ├── 정산 내역 조회
      └── 정산 상세
```

### 2. 주요 화면

#### 2.1 파레트 입고 화면
- **단일 입고**:
  - 파레트 ID 입력 (또는 자동 생성)
  - 화주사 선택 (검색형 드롭다운)
  - 품목명, 입고일, 보관 위치 입력
  - 수량, 서비스 여부 체크박스
  - 비고 입력

- **대량 입고**:
  - CSV/Excel 파일 업로드
  - 파일 형식 안내
  - 업로드 결과 확인

#### 2.2 파레트 출고 화면 (QR 스캔)
- 카메라 활성화 버튼
- QR 코드 스캔 영역
- 스캔 결과 확인
- 보관종료일 입력 (선택사항, 기본값: 현재일)
- 비고 입력
- 보관종료 처리 버튼

#### 2.3 파레트 현황 화면
- **필터**:
  - 화주사 (검색형 드롭다운)
  - 상태 (입고됨, 보관종료, 서비스, 전체)
  - 월 필터 (YYYY-MM 형식)
  
- **테이블**:
  - 파레트 ID
  - 화주사명
  - 품목명
  - 상태
  - 입고일
  - 보관종료일
  - 보관일수
  - 현재 보관료
  - 서비스 여부

- **실시간 업데이트**: 5초 간격 Polling

#### 2.4 보관료 설정 화면 (관리자)
- 화주사 선택 (검색형 드롭다운)
- 월 보관료 입력 (원)
- 일일 보관료 자동 계산 표시
- 적용 시작일 입력
- 비고 입력
- 저장 버튼

#### 2.5 월별 정산 화면
- **정산 내역 조회**:
  - 월 선택 드롭다운 (YYYY-MM 형식)
  - 화주사 필터 (관리자만)
  - 정산 내역 테이블:
    - 화주사명
    - 정산월
    - 총 파레트 수
    - 총 보관일수
    - 총 보관료
    - 상태
  - 정산 상세 보기 버튼

- **정산 상세**:
  - 정산 정보 (화주사명, 정산월, 총액 등)
  - 파레트별 상세 내역 테이블:
    - 파레트 ID
    - 품목명
    - 입고일
    - 보관종료일
    - 보관일수
    - 일일 보관료
    - 보관료
    - 서비스 여부
  - PDF/Excel 다운로드 버튼
  - 정산 확정 버튼 (관리자만)

### 3. 파일 구조
```
pallets.html              # 새 HTML 파일
  ├── CSS (pal- 접두사)
  ├── JavaScript (pal 접두사)
  └── HTML 구조
```

---

## 모바일 QR 스캔 설계

### 1. 구현 방식
- **HTML5 Camera API**: `getUserMedia()` 사용
- **QR 코드 라이브러리**: `html5-qrcode` 또는 `jsQR`
- **모바일 브라우저 지원**: iOS Safari, Android Chrome

### 2. 플로우
1. "QR 스캔" 버튼 클릭
2. 카메라 권한 요청
3. 카메라 활성화 및 QR 코드 스캔 영역 표시
4. QR 코드 스캔
5. 파레트 ID 추출
6. API 호출: `POST /api/pallets/qr/scan` (파레트 정보 조회)
7. 파레트 정보 확인 모달 표시
8. 보관종료 처리 확인
9. API 호출: `POST /api/pallets/outbound` (보관종료 처리)
10. 처리 결과 표시

### 3. 오류 처리
- QR 코드 인식 실패: 재시도 안내
- 파레트 ID 없음: 오류 메시지 표시
- 이미 보관종료된 파레트: 경고 메시지 표시
- 카메라 권한 거부: 수동 입력 옵션 제공

---

## 권한 관리

### 1. 데이터 필터링 로직

```python
def get_user_context():
    """
    요청 헤더에서 사용자 정보 추출
    """
    role = request.headers.get('X-User-Role', '화주사')
    company_name = request.headers.get('X-Company-Name', '')
    username = request.headers.get('X-Username', '')
    
    return role, company_name, username

def filter_by_company(query: str, params: list, role: str, company_name: str):
    """
    화주사별 데이터 필터링
    """
    if role != '관리자' and company_name:
        query += " AND company_name = ?"
        params.append(company_name)
    
    return query, params
```

### 2. API 권한 체크
- **관리자**: 모든 데이터 조회/수정 가능
- **화주사**: 자신의 `company_name` 데이터만 조회 가능
- **수정/삭제**: 관리자만 가능 (화주사는 조회만)

---

## 모듈 구조

### 1. 파일 구조
```
api/
  └── pallets/
      ├── __init__.py
      ├── routes.py         # API 엔드포인트
      └── models.py         # 데이터베이스 함수

pallets.html               # 프론트엔드 HTML
```

### 2. 접두사 규칙
- **HTML ID/Class**: `pal-` 접두사 (예: `pal-pallet-list`, `pal-fee-calculator`)
- **JavaScript 함수**: `pal` 접두사 (예: `palInbound()`, `palLoadPallets()`)
- **CSS 클래스**: `pal-` 접두사 (예: `.pal-container`, `.pal-table`)

### 3. Blueprint 등록
```python
# app.py에 추가
from api.pallets.routes import pallets_bp
app.register_blueprint(pallets_bp)
```

---

## 개발 순서

### 1단계: 데이터베이스 스키마 생성
- [ ] `pallets` 테이블 생성
- [ ] `pallet_fees` 테이블 생성
- [ ] `pallet_transactions` 테이블 생성
- [ ] `pallet_monthly_settlements` 테이블 생성
- [ ] `pallet_fee_calculations` 테이블 생성
- [ ] 인덱스 생성
- [ ] `api/database/models.py`에 테이블 생성 함수 추가

### 2단계: 백엔드 API 개발
- [ ] `api/pallets/models.py` 생성 (데이터베이스 함수)
  - [ ] `create_pallet()` - 파레트 입고
  - [ ] `update_pallet_status()` - 보관종료 처리
  - [ ] `get_pallets()` - 파레트 목록 조회
  - [ ] `get_pallet_by_id()` - 파레트 상세 조회
  - [ ] `calculate_fee()` - 보관료 계산
  - [ ] `get_monthly_fee()` - 화주사별 월 보관료 조회
  - [ ] `set_monthly_fee()` - 보관료 설정
  - [ ] `generate_settlement()` - 월별 정산 생성
  - [ ] `get_settlements()` - 정산 내역 조회

- [ ] `api/pallets/routes.py` 생성 (API 엔드포인트)
  - [ ] 파레트 입고 API
  - [ ] 파레트 보관종료 API
  - [ ] 파레트 목록 조회 API
  - [ ] 파레트 상세 조회 API
  - [ ] 보관료 설정 API
  - [ ] 보관료 계산 API
  - [ ] 월별 정산 생성 API
  - [ ] 월별 정산 조회 API
  - [ ] QR 코드 스캔 API

### 3단계: 프론트엔드 기본 UI
- [ ] `pallets.html` 생성
- [ ] 파레트 입고 화면 구현
- [ ] 파레트 현황 화면 구현
- [ ] 보관료 설정 화면 구현 (관리자)
- [ ] 월별 정산 화면 구현

### 4단계: QR 스캔 기능
- [ ] HTML5 Camera API 연동
- [ ] QR 코드 스캔 라이브러리 통합
- [ ] QR 스캔 화면 구현
- [ ] 보관종료 처리 연동

### 5단계: 정산 기능
- [ ] 월별 정산 생성 로직 구현
- [ ] 정산 내역 조회 구현
- [ ] 정산 상세 화면 구현
- [ ] PDF/Excel 다운로드 기능 (선택사항)

### 6단계: 테스트 및 최적화
- [ ] 기능 테스트
- [ ] 권한 테스트
- [ ] 성능 최적화
- [ ] 사용자 피드백 반영

---

## 데이터 마이그레이션

### 1. 마이그레이션 전략
1. **Google Sheets 데이터 추출**
   - Google Sheets API로 데이터 읽기
   - CSV/Excel 파일로 내보내기

2. **데이터 검증 및 정제**
   - 파레트 ID 중복 체크
   - 날짜 형식 변환
   - 화주사명 정규화

3. **데이터베이스 임포트**
   - 배치 삽입
   - 중복 체크 및 오류 처리
   - 트랜잭션 처리

4. **검증 및 테스트**
   - 데이터 무결성 검증
   - 보관료 계산 정확성 검증
   - 정산 내역 비교

### 2. 마이그레이션 스크립트
```python
# migrate_pallets.py (별도 스크립트)
def migrate_from_google_sheets():
    """
    Google Sheets에서 파레트 데이터 마이그레이션
    """
    # 1. Google Sheets 데이터 읽기
    # 2. 데이터 정제
    # 3. 데이터베이스 삽입
    # 4. 검증
    pass
```

---

## 주의사항

### 1. 기존 코드 수정 금지
- ✅ 새로운 파일만 생성 (`api/pallets/`, `pallets.html`)
- ✅ `app.py`에 Blueprint 등록만 추가
- ✅ `dashboard_server.html`에 메뉴 버튼만 추가
- ❌ 기존 파일 수정 금지

### 2. 모듈 독립성
- 모든 기능을 `pal-` 접두사로 구분
- 기존 코드와 충돌하지 않도록 주의

### 3. 데이터 무결성
- 파레트 ID 중복 방지
- 입고일 > 보관종료일 검증
- 보관료 계산 정확성 검증

### 4. 성능 최적화
- 대량 데이터 처리 시 배치 처리
- 인덱스 활용
- 캐싱 전략 (필요시)

---

## 참고사항

### 1. 월 보관료 기본값
- 기본값: 16,000원
- 일일 보관료: 16,000 ÷ 30.44 ≈ 526원

### 2. 보관료 계산 예시
- 입고일: 2025-01-05
- 보관종료일: 2025-01-20
- 보관일수: 16일
- 일일 보관료: 526원
- 계산된 보관료: 526 × 16 = 8,416원
- 백원 단위 올림: 8,500원

### 3. 월별 정산 예시
- 정산월: 2025-01
- 정산 기간: 2025-01-01 ~ 2025-01-31
- 파레트 A: 입고일 2025-01-05, 보관종료일 2025-01-20
  - 보관일수: 16일 (1월 5일 ~ 1월 20일)
  - 보관료: 8,500원
- 파레트 B: 입고일 2025-01-10, 보관종료일 없음 (보관중)
  - 보관일수: 22일 (1월 10일 ~ 1월 31일)
  - 보관료: 11,600원

---

## 완료 체크리스트

### 개발 전
- [ ] 설계 가이드 검토 완료
- [ ] 데이터베이스 스키마 확인
- [ ] API 엔드포인트 설계 확인
- [ ] UI/UX 설계 확인

### 개발 중
- [ ] 데이터베이스 테이블 생성 완료
- [ ] 백엔드 API 개발 완료
- [ ] 프론트엔드 UI 개발 완료
- [ ] QR 스캔 기능 구현 완료
- [ ] 정산 기능 구현 완료

### 테스트
- [ ] 기능 테스트 완료
- [ ] 권한 테스트 완료
- [ ] 성능 테스트 완료
- [ ] 사용자 피드백 반영

### 배포 전
- [ ] 데이터 마이그레이션 준비
- [ ] 기존 데이터 백업
- [ ] 마이그레이션 스크립트 테스트
- [ ] 최종 검증

---

**작성일**: 2025-12-26  
**버전**: 1.0  
**작성자**: AI Assistant

---

## 📋 Google Forms 실시간 동기화 문제 해결 가이드

### 🔍 발생했던 주요 문제들과 해결 방법

#### 문제 1: 트리거가 실행되지만 동기화가 안 되는 경우 ⚠️ 가장 큰 문제

**증상:**
- 트리거는 실행됨 (실행 로그에 함수 실행 기록 있음)
- 하지만 동기화는 되지 않음
- 로그에 `[onChangeForFormSubmit] INSERT_ROW가 아님: undefined, 무시` 메시지

**⚠️ 중요한 교훈:**
- **"양식 제출 시" 트리거가 올바른 선택이었습니다!**
- 제가 잘못 "변경 시" 트리거를 권장했던 것이 문제였습니다
- 사용자가 올바르게 "양식 제출 시"로 설정했지만, 코드가 이를 처리하지 못했던 것이 진짜 문제였습니다

**원인:**
- "양식 제출 시" 트리거를 사용했는데, `onChangeForFormSubmit` 함수가 `e.changeType === 'INSERT_ROW'`만 체크
- "양식 제출 시" 트리거는 `onFormSubmit` 이벤트를 발생시키므로 `e.changeType`이 `undefined`
- `e.values` 배열은 있지만 `e.changeType`이 없어서 조건문에서 무시됨
- **결론: 트리거 설정은 맞았고, 코드가 잘못되었던 것입니다**

**해결 방법:**
```javascript
// onChangeForFormSubmit 함수에서 이벤트 타입 확인
// ⚠️ 중요: "양식 제출 시" 트리거를 우선 처리해야 함!
if (e.values && e.values.length > 0 && !e.changeType) {
  // "양식 제출 시" 트리거인 경우 (올바른 선택!)
  onFormSubmit(e); // onFormSubmit 함수 직접 호출
  return;
}

if (e.changeType && e.changeType !== 'INSERT_ROW') {
  // "변경 시" 트리거인 경우 (대안)
  return;
}
```

**체크리스트:**
- [ ] **"양식 제출 시" 트리거가 올바른 선택입니다** ⭐
- [ ] "양식 제출 시" 트리거는 `onFormSubmit` 이벤트 발생 (changeType 없음, values 있음)
- [ ] "변경 시" 트리거는 `onChange` 이벤트 발생 (changeType 있음)
- [ ] 함수가 "양식 제출 시" 이벤트를 우선 처리하도록 구현
- [ ] 코드가 두 가지 이벤트 타입을 모두 처리할 수 있도록 구현

---

#### 문제 2: Utilities.formatDate 오류

**증상:**
- 트리거 실행 및 데이터 추출은 정상
- 하지만 동기화 중 오류 발생
- 오류 메시지: `The parameters (String,String,String) don't match the method signature for Utilities.formatDate`

**원인:**
- Google Forms에서 받은 타임스탬프가 문자열 형태 (`"2025. 12. 26 오후 6:56:19"`)
- `Utilities.formatDate`는 첫 번째 인자로 Date 객체를 받아야 함
- 문자열을 직접 전달해서 오류 발생

**해결 방법:**
```javascript
// 타임스탬프를 Date 객체로 변환
let timestampDate = timestamp;
if (typeof timestamp === 'string') {
  timestampDate = new Date(timestamp);
  if (isNaN(timestampDate.getTime())) {
    // 변환 실패 시 현재 시간 사용
    timestampDate = new Date();
  }
} else if (!(timestamp instanceof Date)) {
  timestampDate = new Date();
}

// Date 객체를 Utilities.formatDate에 전달
const formattedDate = Utilities.formatDate(
  timestampDate, 
  Session.getScriptTimeZone(), 
  'yyyy-MM-dd HH:mm:ss'
);
```

**체크리스트:**
- [ ] Google Forms에서 받은 타임스탬프는 항상 문자열일 수 있음
- [ ] `Utilities.formatDate` 사용 전에 Date 객체로 변환 필수
- [ ] 변환 실패 시 대체 로직 구현 (현재 시간 사용 등)

---

#### 문제 3: 트리거 배포 설정 누락

**증상:**
- 트리거를 설정했지만 실행되지 않음
- 실행 로그에 함수 실행 기록이 없음

**원인:**
- 트리거 설정 시 "실행할 배포"를 선택하지 않음
- Google Apps Script에서 트리거는 반드시 배포를 지정해야 함

**해결 방법:**
1. Google Sheets → 확장 프로그램 → Apps Script
2. 왼쪽 메뉴에서 "트리거" 클릭
3. 트리거 설정 시 **반드시** 다음 항목 모두 선택:
   - 실행할 함수: `onChangeForFormSubmit` (또는 `onFormSubmit`)
   - **실행할 배포: Head** ⚠️ 필수!
   - 이벤트 소스: 스프레드시트에서
   - 이벤트 유형: 양식 제출 시 (또는 변경 시)

**체크리스트:**
- [ ] 트리거 설정 시 "실행할 배포" 반드시 "Head" 선택
- [ ] 트리거 목록에서 배포 정보 확인
- [ ] 트리거가 실행되지 않으면 배포 설정 확인

---

### 🛠️ 트리거 설정 가이드

#### ⭐ 올바른 트리거 설정 (반드시 이렇게 설정하세요!)

**"양식 제출 시" 트리거 (유일한 올바른 선택)**
- 실행할 함수: `onChangeForFormSubmit` (또는 `onFormSubmit`)
- 실행할 배포: `Head` ⚠️ 필수!
- 이벤트 소스: 스프레드시트에서
- 이벤트 유형: **양식 제출 시** ⭐

**⚠️ 중요:**
- **"양식 제출 시" 트리거가 올바른 선택입니다**
- 제가 잘못 "변경 시"를 권장했던 것이 문제였습니다
- Google Forms 응답을 처리하려면 반드시 "양식 제출 시"를 사용해야 합니다
- "변경 시" 트리거는 다른 용도로만 사용하세요

**왜 "양식 제출 시"가 올바른가?**
- Google Forms 제출 시 즉시 실행됨
- `e.values` 배열에 모든 응답 데이터가 포함됨
- `e.changeType`은 없지만, 이는 정상입니다 (코드에서 처리해야 함)
- 가장 직접적이고 안정적인 방법입니다

---

### 🐛 디버깅 체크리스트

동기화가 안 될 때 확인할 사항:

1. **트리거 설정 확인**
   - [ ] 트리거가 설정되어 있는지 확인
   - [ ] "실행할 배포"가 "Head"로 설정되어 있는지 확인
   - [ ] 함수 이름이 정확한지 확인

2. **실행 로그 확인**
   - [ ] Google Apps Script → 실행 메뉴에서 로그 확인
   - [ ] 트리거가 실행되었는지 확인
   - [ ] 오류 메시지가 있는지 확인

3. **이벤트 타입 확인**
   - [ ] 로그에서 `changeType: undefined` 확인 (양식 제출 시)
   - [ ] 로그에서 `values: 있음` 확인
   - [ ] 함수가 올바른 이벤트 타입을 처리하는지 확인

4. **데이터 타입 확인**
   - [ ] 타임스탬프가 문자열인지 Date 객체인지 확인
   - [ ] `Utilities.formatDate`에 Date 객체 전달하는지 확인
   - [ ] 변환 실패 시 대체 로직이 있는지 확인

5. **API 연결 확인**
   - [ ] API 서버 주소가 올바른지 확인
   - [ ] API 응답 코드 확인 (200/201이어야 함)
   - [ ] API 응답 내용 확인 (오류 메시지 확인)

---

### 📝 코드 작성 시 주의사항

#### 1. 이벤트 객체 처리

```javascript
// ❌ 잘못된 방법
function onChangeForFormSubmit(e) {
  if (e.changeType !== 'INSERT_ROW') {
    return; // 양식 제출 시 무시됨!
  }
}

// ✅ 올바른 방법
function onChangeForFormSubmit(e) {
  // 양식 제출 이벤트 처리
  if (e.values && e.values.length > 0 && !e.changeType) {
    onFormSubmit(e);
    return;
  }
  
  // 변경 이벤트 처리
  if (e.changeType && e.changeType !== 'INSERT_ROW') {
    return;
  }
}
```

#### 2. 날짜/시간 처리

```javascript
// ❌ 잘못된 방법
Utilities.formatDate(timestamp, Session.getScriptTimeZone(), 'yyyy-MM-dd');
// timestamp가 문자열이면 오류 발생!

// ✅ 올바른 방법
let timestampDate = timestamp;
if (typeof timestamp === 'string') {
  timestampDate = new Date(timestamp);
  if (isNaN(timestampDate.getTime())) {
    timestampDate = new Date(); // 대체값
  }
}
Utilities.formatDate(timestampDate, Session.getScriptTimeZone(), 'yyyy-MM-dd');
```

#### 3. 트리거 함수 설계

```javascript
// ✅ 양식 제출과 변경 이벤트 모두 처리
function onChangeForFormSubmit(e) {
  // 1. 양식 제출 이벤트 확인
  if (e.values && !e.changeType) {
    onFormSubmit(e);
    return;
  }
  
  // 2. 변경 이벤트 확인
  if (e.changeType === 'INSERT_ROW') {
    // 처리 로직
  }
}
```

---

### 🎯 최종 확인 사항

동기화가 정상 작동하는지 확인:

1. **트리거 실행 확인**
   - [ ] Google Forms 제출 시 즉시 트리거 실행
   - [ ] 실행 로그에 함수 실행 기록 있음

2. **데이터 추출 확인**
   - [ ] 파레트 ID, 작업 유형 등 필수 데이터 추출 성공
   - [ ] 타임스탬프 변환 성공

3. **API 호출 확인**
   - [ ] API 요청 성공 (응답 코드 200/201)
   - [ ] 오류 메시지 없음

4. **웹사이트 확인**
   - [ ] 웹사이트에서 새 파레트 즉시 확인 가능
   - [ ] 데이터가 올바르게 저장됨

---

---

### ⚠️ 중요한 교훈

**가장 큰 문제:**
- 제가 계속 "변경 시" 트리거를 권장했지만, 실제로는 **"양식 제출 시" 트리거가 올바른 선택**이었습니다
- 사용자가 올바르게 "양식 제출 시"로 설정했지만, 코드가 이를 처리하지 못해서 동기화가 안 되었습니다
- **트리거 설정은 맞았고, 코드 로직이 문제였던 것입니다**

**앞으로의 원칙:**
1. Google Forms 응답을 처리할 때는 **반드시 "양식 제출 시" 트리거 사용**
2. 코드는 "양식 제출 시" 이벤트(`e.values` 있음, `e.changeType` 없음)를 우선 처리
3. 트리거 설정이 맞는데 동기화가 안 되면, 코드 로직을 먼저 확인

---

**작성일**: 2025-12-26  
**업데이트**: Google Forms 동기화 문제 해결 가이드 추가  
**수정**: "양식 제출 시" 트리거가 올바른 선택임을 명확히 정정


