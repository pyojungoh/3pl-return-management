# 프로젝트 작업 규칙 및 주의사항

## ⛔ 하지 말아야 할 것들

1. **터미널 명령어 실행**
   - 이제부터 터미널 명령어를 직접 실행할 수 있음
   - 배포 작업 시 git 명령어를 직접 실행 가능
   - 필요시 사용자에게 확인 후 실행

2. **불필요한 .md 파일 생성 금지**
   - 설명 문서나 가이드 파일을 만들지 말 것
   - 사용자가 명시적으로 요청한 경우만 생성

3. **명령어를 하나의 코드 블록에 묶지 말 것**
   - 각 명령어를 개별 코드 블록으로 제공
   - 복사하기 편하도록 하나씩 따로 제공

4. **Railway 관련 작업 금지**
   - 이 프로젝트는 GitHub + Vercel을 사용
   - Railway 관련 파일이나 설정 제안하지 말 것

5. **Git 커밋 메시지 인코딩 문제 방지**
   - ⚠️ **절대 금지**: Git 커밋 메시지에 한글을 사용하면 안 됨
   - 한글 커밋 메시지는 인코딩 문제로 푸시가 실패하거나 깨질 수 있음
   - **반드시 영문으로만 커밋 메시지 작성**
   - 예시:
     - ❌ 잘못된 예: `git commit -m "사업자 정보 필수 팝업 모달 추가"`
     - ✅ 올바른 예: `git commit -m "Add business info required modal popup"`
   - 커밋 메시지 형식:
     - 동사로 시작 (Add, Fix, Update, Remove, Refactor 등)
     - 간결하고 명확하게 작성
     - 필요시 여러 줄로 상세 설명 추가 가능

## ✅ 수정 시 주의사항

### 0. ⚠️ 새로운 기능 추가 시 기존 기능 유지 (최우선 원칙)
- **절대 금지**: 새로운 기능을 추가한다고 해서 기존 기능이 사라지거나 작동하지 않게 만들면 안 됨
- **기존 기능 목록** (반드시 유지해야 할 기능들):
  1. **인증 기능** (`api/auth/routes_db.py`):
     - 로그인 (`/api/auth/login`)
     - 화주사 등록 (`/api/auth/register`)
     - 비밀번호 변경 (`/api/auth/change-password`)
     - 화주사 정보 조회/수정 (`/api/auth/my-info`, `/api/auth/company-info`)
     - 화주사 목록 조회 (`/api/auth/companies`)
  2. **반품 관리 기능** (`api/returns/routes_db.py`):
     - 반품 등록 (`/api/returns/create`)
     - 반품 목록 조회 (`/api/returns/data`)
     - 반품 상세 조회 (`/api/returns/<id>`)
     - 반품 수정/삭제 (`/api/returns/<id>`)
     - 완료 처리 (`/api/returns/<id>/complete`)
     - 메모 저장 (`/api/returns/<id>/memo`)
     - 월별 데이터 조회 (`/api/returns/available-months`)
     - CSV 내보내기 (`/api/returns/export`)
  3. **이미지 업로드 기능** (`api/uploads/routes.py`):
     - 이미지 업로드 (`/api/uploads/upload-images`)
     - 송장번호로 검색 (`/api/uploads/find-by-tracking`)
  4. **모바일 페이지** (`index.html`):
     - QR 코드 스캔 기능
     - 송장번호 검색
     - 반품 등록
     - 사진 업로드
     - 화주사 등록
     - 비밀번호 변경
  5. **대시보드** (`dashboard_server.html`):
     - 관리자 모드 (반품 관리, 화주사 관리, 게시판 관리, 스케쥴 관리, 팝업 관리)
     - 화주사 모드 (반품 조회, 게시판, 판매스케쥴, 화주사 정보)
     - 로그인 기능
     - F5 새로고침 시 메뉴/탭 유지
  6. **게시판 기능** (`api/board/routes_db.py`):
     - 게시글 작성/수정/삭제
     - 카테고리 관리
     - 파일 첨부
  7. **스케쥴 기능** (`api/schedules/routes_db.py`):
     - 스케쥴 등록/수정/삭제
     - 달력 뷰
  8. **팝업 기능** (`api/popups/routes_db.py`):
     - 팝업 등록/수정/삭제
     - 활성 팝업 조회
- **작업 전 체크리스트**:
  - [ ] 새 기능 추가 전에 기존 기능 목록 확인
  - [ ] 기존 API 엔드포인트가 변경되지 않는지 확인
  - [ ] 기존 HTML 요소나 JavaScript 함수가 삭제되지 않는지 확인
  - [ ] 기존 데이터베이스 테이블이나 컬럼이 삭제되지 않는지 확인
  - [ ] 기존 파일이 삭제되거나 이름이 변경되지 않는지 확인
- **작업 후 체크리스트**:
  - [ ] 모든 기존 기능이 정상 작동하는지 테스트
  - [ ] 기존 API 엔드포인트가 여전히 작동하는지 확인
  - [ ] 기존 페이지가 정상적으로 로드되는지 확인
  - [ ] 기존 데이터가 정상적으로 조회/수정되는지 확인
- **주의사항**:
  - 기존 코드를 수정할 때는 최소한의 변경만 수행
  - 기존 함수나 API를 삭제하지 말고, 필요시 확장만 수행
  - 기존 HTML 요소를 삭제하지 말고, 필요시 새로운 요소만 추가
  - 기존 데이터베이스 스키마를 변경할 때는 하위 호환성 유지

### 1. 파일 삭제 시 확인
- 실제 사용 중인 파일인지 반드시 확인
- `__init__.py` 파일들이 올바른 모듈을 import하는지 확인
- `app.py`에서 사용하는 파일인지 확인

### 2. 데이터베이스 호환성
- **로컬**: SQLite 사용 (`data.db`)
- **배포 (Vercel)**: PostgreSQL/Neon 사용
- 두 환경 모두 지원하도록 코드 작성

### 3. Import 에러 방지
- SQLite 모드: `from sqlite3 import OperationalError, IntegrityError`
- PostgreSQL 모드: `from psycopg2 import IntegrityError, OperationalError`
- `api/database/models.py`에서 두 가지 모두 import 필요

### 4. __init__.py 파일 확인
- `api/auth/__init__.py`: `from .routes_db import auth_bp` (routes.py 아님)
- `api/returns/__init__.py`: `from .routes_db import returns_bp` (routes.py 아님)
- 파일 삭제 후 반드시 확인 필요

### 5. 메인 파일
- **HTML**: `dashboard_server.html` (메인 파일)
- `dashboard.html`, `dashboard_simple.html` 등은 삭제됨
- `app.py`는 `dashboard_server.html`만 사용

### 6. 모바일 페이지 (매우 중요)
- **파일**: `index.html` (QR 모바일 페이지)
- **라우트**: `/qrmobile`, `/admin` (레거시 경로)
- **중요도**: ⭐⭐⭐⭐⭐ (최우선)
  - 실제 물류 현장에서 사용하는 핵심 페이지
  - 반품 등록 및 사진 업로드의 주요 진입점
  - 이 페이지가 작동하지 않으면 현장 업무가 중단됨
- **주요 기능**:
  1. **QR 코드 스캔**: jsQR 라이브러리 사용, 카메라로 송장번호 자동 인식
  2. **송장번호 검색**: `/api/uploads/find-by-tracking` API 사용
  3. **반품 등록**: `/api/returns/create` API로 데이터 저장
  4. **사진 업로드**: `/api/uploads/upload-images` API로 Cloudinary 업로드
  5. **화주사 등록**: `/api/auth/register` API 사용
  6. **비밀번호 변경**: `/api/auth/change-password` API 사용
  7. **월별 데이터 조회**: `/api/returns/available-months` API 사용
- **작동 방식**:
  - 모바일 최적화 (반응형 디자인, 터치 친화적)
  - QR 코드 스캔 → 송장번호 자동 입력 → 데이터 검색 → 사진 업로드 → 반품 등록
  - HTTPS 필수 (카메라 접근을 위해)
  - 월 선택 후 해당 월의 데이터에서만 검색 (없으면 모든 월에서 검색)
- **주의사항**:
  - **절대 삭제하면 안 됨** - 현장 업무 중단
  - 파일 수정 시 반드시 테스트 필요 (QR 스캔, 사진 업로드, 데이터 저장)
  - 카메라 권한 요청 처리 필수
  - 모바일 브라우저 호환성 확인 필요
  - API 엔드포인트 변경 시 이 페이지도 함께 수정 필요

## 🎯 새로운 작업 규칙 (2025-11-14 추가)

### 1. 모듈화 원칙
- **기존 코딩은 그대로 유지**: 기존에 작성된 코드는 수정하지 않고 그대로 유지
- **새로운 메뉴는 모듈화**: 새롭게 추가되는 메뉴들은 반드시 모듈화하여 코딩
  - 한 페이지에 모든 코드가 몰리지 않도록 분리
  - 수정이 용이하도록 독립적인 모듈로 구성
  - 예시: 새로운 메뉴의 HTML, CSS, JavaScript를 별도 파일로 분리하거나, 최소한 함수 단위로 명확히 구분

### 2. 리스트 순번 규칙
- **새로운 리스트 생성 시**: 항상 맨 앞에 순번(번호) 컬럼이 들어가야 함
  - 첫 번째 컬럼은 항상 순번
  - 순번은 1부터 시작하여 순차적으로 증가
  - 예시: `<th>순번</th><th>이름</th><th>날짜</th>...`

### 3. 리스트 가운데 정렬 규칙
- **모든 리스트**: 항상 가운데 정렬되어야 함
  - 테이블 헤더(`<th>`): `text-align: center;`
  - 테이블 데이터(`<td>`): `text-align: center;`
  - 리스트 아이템: 중앙 정렬 스타일 적용

### 4. F5 새로고침 시 메뉴 유지 규칙
- **새로운 메뉴 추가 시 필수**: F5 새로고침을 눌러도 해당 메뉴에서 새로고침되어야 함
  - 다른 메뉴로 이동되면 안 됨
  - 현재 활성화된 메뉴/탭이 유지되어야 함
- **구현 방법**:
  - 메뉴/탭 전환 시 `localStorage`에 현재 메뉴/탭 저장
  - 페이지 로드 시 `localStorage`에서 저장된 메뉴/탭 복원
  - 관리자 모드: `localStorage.setItem('activeAdminTab', tabName)`
  - 화주사 모드: `localStorage.setItem('activeConsignorMenu', menuName)`
- **체크리스트** (새 메뉴 추가 후):
  - [ ] 메뉴 전환 시 localStorage에 저장되는지 확인
  - [ ] F5 새로고침 후 해당 메뉴가 유지되는지 확인
  - [ ] 다른 메뉴로 이동 후 F5 새로고침 시 해당 메뉴가 유지되는지 확인

## 📋 프로젝트 구조

### 주요 파일
- `app.py`: Flask 메인 서버
- `dashboard_server.html`: 메인 대시보드 (로그인 + 관리 화면)
- `index.html`: **QR 모바일 페이지** (매우 중요 - 현장 업무 핵심)
- `api/database/models.py`: 데이터베이스 모델 (SQLite/PostgreSQL 호환)
- `api/auth/routes_db.py`: 인증 API (로그인, 회원가입)
- `api/returns/routes_db.py`: 반품 데이터 API
- `api/admin/routes.py`: 관리자 API (CSV 마이그레이션 등)
- `api/uploads/routes.py`: 이미지 업로드 API

### 데이터베이스
- 로컬: SQLite (`data.db`)
- 배포: PostgreSQL/Neon (환경변수 `DATABASE_URL`)

### 배포
- GitHub에 푸시
- Vercel 자동 배포
- 환경변수: `DATABASE_URL` (PostgreSQL 연결 문자열)
- 도메인: `jjaysolution.com` (Vercel에서 구매 및 연결 완료)

## 🔧 일반적인 작업 흐름

### 코드 수정 후 배포
1. 수정 완료
2. 터미널 명령어 직접 실행 (git add, commit, push)
3. Vercel 자동 배포 대기

### 파일 삭제 시 체크리스트
- [ ] `app.py`에서 import하는지 확인
- [ ] `__init__.py`에서 import하는지 확인
- [ ] 다른 파일에서 사용하는지 확인 (grep으로 검색)
- [ ] 삭제 후 관련 import 경로 수정

### 데이터베이스 관련 수정 시
- [ ] SQLite와 PostgreSQL 모두 테스트
- [ ] `OperationalError`, `IntegrityError` import 확인
- [ ] 환경변수 `DATABASE_URL` 확인

## 🚨 자주 발생하는 오류

### 1. ModuleNotFoundError
- `__init__.py`에서 삭제된 파일을 import하는 경우
- 해결: `routes_db.py`로 변경

### 2. NameError: name 'OperationalError' is not defined
- SQLite 모드에서 `OperationalError` import 누락
- 해결: `from sqlite3 import OperationalError, IntegrityError` 추가

### 3. 화주사 등록 오류
- None 값에 `.strip()` 호출
- 해결: None 체크 후 처리

### 4. 화주사 데이터 필터링 문제
- 관리자는 모든 데이터, 화주사는 자신의 데이터만
- 해결: `company` 파라미터로 필터링

## 📝 기타 주의사항

1. **언어**: 항상 한국어로 응답
2. **터미널 명령어**: 필요시 직접 실행 가능 (git 배포 등)
3. **파일 삭제**: 신중하게 확인 후 삭제
4. **에러 처리**: 상세한 로그 추가하여 디버깅 용이하게
5. **코드 수정**: 기존 기능을 깨뜨리지 않도록 주의
6. **기존 기능 유지**: 새로운 기능 추가 시 기존 기능이 사라지면 안 됨 (최우선 원칙)

## 🔄 작업 시 확인 사항

1. **기존 기능 유지 확인** (최우선):
   - [ ] 새로운 기능 추가 시 기존 기능이 사라지지 않았는지 확인
   - [ ] 기존 API 엔드포인트가 정상 작동하는지 확인
   - [ ] 기존 페이지가 정상적으로 로드되는지 확인
   - [ ] 기존 데이터가 정상적으로 조회/수정되는지 확인
2. 로컬에서 테스트 가능한지
3. 배포 후에도 작동하는지
4. SQLite와 PostgreSQL 모두 지원하는지
5. 기존 기능이 깨지지 않았는지
6. 에러 처리가 적절한지

## 📌 중요 기능 규칙

### F5 새로고침 시 현재 메뉴/탭 유지
- **관리자 모드**: `localStorage.setItem('activeAdminTab', tabName)` - 현재 활성 탭 저장
- **화주사 모드**: `localStorage.setItem('activeConsignorMenu', menuName)` - 현재 활성 메뉴 저장
- **복원 로직**: 페이지 로드 시 `localStorage.getItem()`으로 저장된 값 복원
- **기본값**: 저장된 값이 없으면 관리자는 'returns', 화주사는 'returns' 메뉴로 이동
- **주의사항**: 어떤 메뉴가 추가되어도 반드시 이 규칙을 따라야 함
  - 메뉴/탭 전환 시 localStorage에 저장
  - 페이지 로드 시 저장된 값으로 복원
  - 새로고침(F5) 후에도 현재 메뉴/탭이 유지되어야 함
- **⚠️ 새로운 메뉴/탭 추가 시 필수 작업 (반드시 확인)**:
  1. **메뉴 전환 함수에 localStorage 저장 추가**:
     - 화주사 모드: `switchMenu()` 함수에서 `localStorage.setItem('activeConsignorMenu', menuName)` 추가 확인
     - 관리자 모드: `switchAdminTab()` 함수에서 `localStorage.setItem('activeAdminTab', tabName)` 추가 확인
  2. **페이지 로드 시 복원 로직 추가**:
     - 화주사 모드: `showDashboard()` 함수에서 `localStorage.getItem('activeConsignorMenu')`로 저장된 메뉴 복원 확인
     - 관리자 모드: `showDashboard()` 함수에서 `localStorage.getItem('activeAdminTab')`로 저장된 탭 복원 확인
     - `validTabs` 또는 `validMenus` 배열에 새로운 메뉴/탭 이름 추가 확인
  3. **검증 리스트 (새로운 메뉴 추가 후 반드시 테스트)**:
     - [ ] 새로운 메뉴/탭 전환 시 localStorage에 저장되는지 확인
     - [ ] F5 새로고침 후 해당 메뉴/탭이 유지되는지 확인
     - [ ] 다른 메뉴로 이동 후 F5 새로고침 시 해당 메뉴가 유지되는지 확인
     - [ ] 로그아웃 후 다시 로그인 시 기본 메뉴로 이동하는지 확인

## 🖼️ 이미지 호스팅 정보

### Cloudinary 설정
- **서비스**: Cloudinary (이미지/파일 호스팅)
- **Cloud Name**: `dokk81rjh`
- **API Key**: `447577332396678`
- **API Secret**: `_fh-dOMoaFvOvCRkFk_AzqjOFA8`
- **설정 파일**: `api/uploads/cloudinary_upload.py`
- **환경 변수** (선택사항):
  - `CLOUDINARY_CLOUD_NAME`
  - `CLOUDINARY_API_KEY`
  - `CLOUDINARY_API_SECRET`

### 로고 URL
- **현재 사용 중인 로고 URL**: `https://res.cloudinary.com/dokk81rjh/image/upload/v1762922695/logo_srff9i.png`
- **위치**: `dashboard_server.html` (헤더 로고)
- **설정 위치**: `dashboard_server.html` 1393줄

### Cloudinary 업로드 폴더 구조
- **반품 내역 이미지**: `반품내역/년월/송장번호_타임스탬프_번호`
- **사업자 등록증**: `business_certificates/파일명_타임스탬프`
- **게시판 첨부파일**: `board_files/파일명`
- **팝업 이미지**: `board_files/파일명` (게시판 업로드 API 재사용)

### 주요 함수
- `upload_images_to_cloudinary()`: 반품 내역 이미지 업로드
- `upload_single_file_to_cloudinary()`: 단일 파일 업로드 (사업자 등록증 등)
- `upload_to_cloudinary()`: 일반 파일 업로드 (게시판, 팝업 등)

## 📸 사진 업로드 기능 가이드 (매우 중요)

### ⚠️ 주의사항
- **사진 업로드 기능은 매우 중요한 기능입니다**
- 코드 수정 시 사진 업로드가 막히는 경우가 자주 발생함
- 아래 가이드를 반드시 따라야 함
- 수정 후 반드시 테스트 필요

### 🔑 핵심 원칙

#### 1. 프론트엔드 (index.html) - 이미지 업로드 처리
- **위치**: `index.html`의 `submitForm()` 함수
- **핵심 코드 구조**:
  ```javascript
  // 1. 응답 상태 코드 확인 필수
  .then(response => {
    console.log('📥 이미지 업로드 응답 상태:', response.status, response.statusText);
    
    // 2. JSON 응답인지 확인 필수
    const contentType = response.headers.get('content-type');
    if (!contentType || !contentType.includes('application/json')) {
      return response.text().then(text => {
        console.error('❌ JSON이 아닌 응답:', text);
        throw new Error(`서버 오류 (${response.status}): ${text.substring(0, 200)}`);
      });
    }
    
    // 3. JSON 파싱
    return response.json().then(data => {
      console.log('📦 이미지 업로드 응답 데이터:', data);
      
      // 4. HTTP 상태 코드 확인 필수
      if (!response.ok) {
        throw new Error(data.message || `서버 오류 (${response.status})`);
      }
      
      // 5. success 필드 확인
      if (data.success) {
        // 성공 처리
      } else {
        throw new Error(data.message || '이미지 업로드 실패');
      }
    });
  })
  .catch(error => {
    // 6. 에러 처리 필수 (네트워크 오류 포함)
    console.error('❌ 이미지 업로드 오류:', error);
    // 에러 메시지 개선 필요
  });
  ```

#### 2. 서버 측 (api/uploads/routes.py) - 에러 처리
- **위치**: `api/uploads/routes.py`의 `upload_images()` 함수
- **핵심 코드 구조**:
  ```python
  @uploads_bp.route('/upload-images', methods=['POST'])
  def upload_images():
      try:
          # 1. 요청 로그 출력 필수
          print(f"📤 이미지 업로드 API 호출됨")
          print(f"   요청 URL: {request.url}")
          print(f"   Content-Type: {request.content_type}")
          
          # 2. JSON 데이터 확인 필수
          if not request.is_json:
              return jsonify({
                  'success': False,
                  'message': 'JSON 형식의 데이터가 필요합니다.'
              }), 400
          
          data = request.get_json()
          if not data:
              return jsonify({
                  'success': False,
                  'message': '요청 데이터가 없습니다.'
              }), 400
          
          # 3. 필수 필드 확인
          images = data.get('images', [])
          tracking_number = data.get('trackingNumber', '').strip()
          
          if not images or len(images) == 0:
              return jsonify({
                  'success': False,
                  'message': '이미지 데이터가 없습니다.'
              }), 400
          
          # 4. Cloudinary 업로드 (별도 try-except로 감싸기)
          try:
              photo_links = upload_images_to_drive(images, tracking_number)
              
              if not photo_links:
                  return jsonify({
                      'success': False,
                      'message': '이미지 업로드는 완료되었지만 링크를 가져올 수 없습니다.'
                  }), 500
              
              return jsonify({
                  'success': True,
                  'photoLinks': photo_links,
                  'message': f'{len(images)}장의 이미지가 업로드되었습니다.'
              })
          except Exception as upload_error:
              # 5. Cloudinary 오류 처리 (상세 로그 + 에러 메시지 개선)
              print(f"❌ Cloudinary 업로드 오류: {upload_error}")
              import traceback
              traceback.print_exc()
              
              # 에러 메시지 개선
              error_message = str(upload_error)
              if 'Cloudinary 설정' in error_message or '인증' in error_message:
                  error_message = 'Cloudinary 설정 오류: 환경 변수를 확인해주세요.'
              elif 'unauthorized' in error_message.lower() or '401' in error_message:
                  error_message = 'Cloudinary 인증 오류: API 키를 확인해주세요.'
              
              return jsonify({
                  'success': False,
                  'message': f'이미지 업로드 실패: {error_message}'
              }), 500
      
      except Exception as e:
          # 6. 전체 오류 처리 (상세 로그)
          print(f'❌ 이미지 업로드 API 오류: {e}')
          import traceback
          traceback.print_exc()
          return jsonify({
              'success': False,
              'message': f'이미지 업로드 실패: {str(e)}'
          }), 500
  ```

### ✅ 체크리스트 (코드 수정 시 반드시 확인)

#### 프론트엔드 체크리스트
- [ ] `response.ok` 또는 `response.status` 확인하는가?
- [ ] JSON 응답인지 `content-type` 확인하는가?
- [ ] `response.json()` 호출 전에 에러 처리하는가?
- [ ] `data.success` 필드 확인하는가?
- [ ] 네트워크 오류(`TypeError`, `fetch` 관련) 처리하는가?
- [ ] 콘솔 로그가 충분한가? (`📤`, `📥`, `📦`, `✅`, `❌`)
- [ ] 에러 메시지가 사용자에게 명확한가?

#### 서버 측 체크리스트
- [ ] 요청 로그가 충분한가? (요청 URL, Content-Type, 이미지 개수, 송장번호)
- [ ] `request.is_json` 확인하는가?
- [ ] `request.get_json()` 결과가 None인지 확인하는가?
- [ ] 필수 필드(`images`, `trackingNumber`) 확인하는가?
- [ ] Cloudinary 업로드를 별도 try-except로 감싸는가?
- [ ] Cloudinary 오류 시 상세 로그(`traceback.print_exc()`) 출력하는가?
- [ ] 에러 메시지를 사용자 친화적으로 개선하는가?
- [ ] HTTP 상태 코드를 적절히 반환하는가? (400, 500 등)

### 🚨 자주 발생하는 문제와 해결 방법

#### 1. 사진 업로드가 막히는 문제
- **원인**: `response.json()`을 바로 호출하고 `response.ok`를 확인하지 않음
- **해결**: 
  1. `response.status` 확인
  2. `content-type` 확인
  3. `response.ok` 확인 후 JSON 파싱

#### 2. 에러 메시지가 표시되지 않는 문제
- **원인**: 네트워크 오류나 JSON 파싱 오류를 catch하지 않음
- **해결**: 
  1. `response.text()`로 먼저 읽기 (JSON이 아닌 경우)
  2. `catch` 블록에서 모든 에러 처리
  3. 에러 타입별로 메시지 개선

#### 3. Cloudinary 업로드는 성공했지만 저장이 안 되는 문제
- **원인**: `photo_links`가 빈 문자열이거나 None
- **해결**: 
  1. `photo_links` 확인 후 저장
  2. 빈 문자열 체크 추가
  3. 업로드 후 링크 개수 확인

#### 4. 서버 오류가 클라이언트에 전달되지 않는 문제
- **원인**: 서버에서 상세 로그를 출력하지 않음
- **해결**: 
  1. 모든 단계에서 `print()` 로그 출력
  2. `traceback.print_exc()` 사용
  3. 에러 메시지를 명확하게 작성

### 📝 수정 시 따라야 할 순서

1. **프론트엔드 수정 시**:
   - `index.html`의 `submitForm()` 함수 확인
   - 위의 "프론트엔드 체크리스트" 확인
   - 콘솔 로그 확인
   - 실제 모바일에서 테스트

2. **서버 측 수정 시**:
   - `api/uploads/routes.py`의 `upload_images()` 함수 확인
   - 위의 "서버 측 체크리스트" 확인
   - Vercel 로그 확인
   - 실제 업로드 테스트

3. **수정 후 확인**:
   - 로컬에서 테스트
   - 배포 후 실제 모바일에서 테스트
   - 콘솔 로그와 서버 로그 확인
   - 에러 발생 시 즉시 롤백 고려

### 🔍 디버깅 방법

1. **브라우저 콘솔 확인**:
   - `📤 이미지 업로드 시작`
   - `📥 이미지 업로드 응답 상태`
   - `📦 이미지 업로드 응답 데이터`
   - `❌ 이미지 업로드 오류`

2. **서버 로그 확인 (Vercel)**:
   - `📤 이미지 업로드 API 호출됨`
   - `📸 Cloudinary 업로드 시작`
   - `✅ Cloudinary 업로드 완료`
   - `❌ Cloudinary 업로드 오류`

3. **네트워크 탭 확인**:
   - 요청 URL 확인
   - 요청 헤더 확인
   - 응답 상태 코드 확인
   - 응답 본문 확인

## 🚧 현재 미해결 문제

### 팝업 저장 오류 (2025-11-12)
- **문제**: 팝업 관리에서 저장 버튼 클릭 시 저장이 안 되는 문제
- **증상**: 
  - 콘솔 로그에서 `title` 필드가 빈 문자열로 표시됨
  - "모든 필드를 입력해주세요" 에러 메시지 표시
  - 실제로는 모든 필드가 입력되어 있음
- **원인 분석**:
  - `popupTitle` ID가 두 곳에서 사용됨:
    1. 팝업 레이어의 제목 표시용 `<h2 id="popupTitle">` (1424줄)
    2. 팝업 폼의 입력 필드 `<input type="text" id="popupTitle">` (2054줄 → 수정됨)
  - `getElementById('popupTitle')`이 레이어의 `<h2>` 요소를 먼저 반환
  - `<h2>` 요소는 `value` 속성이 없어 빈 문자열 반환
- **시도한 해결 방법**:
  - 폼의 input 필드 ID를 `popupTitleInput`으로 변경 (2054줄)
  - 관련 JavaScript 함수 모두 업데이트:
    - `savePopup()` - 저장 함수
    - `resetPopupForm()` - 폼 초기화 함수
    - `editPopup()` - 수정 함수
- **현재 상태**: 
  - 코드 수정 완료 및 푸시 완료 (커밋: `89de436`)
  - **아직 테스트 미완료** - 내일 다시 확인 필요
- **다음 단계**:
  1. 배포 후 실제로 저장이 되는지 확인
  2. 콘솔 로그에서 `title` 값이 제대로 읽히는지 확인
  3. 여전히 문제가 있으면 추가 디버깅 필요

## 📋 최근 추가된 기능 (2025-11-12)

### 1. 팝업 관리 기능
- **데이터베이스**: `popups` 테이블 추가
  - 필드: `id`, `title`, `content`, `image_url`, `width`, `height`, `start_date`, `end_date`, `is_active`, `created_at`, `updated_at`
- **API 라우트**: `/api/popups/`
  - `GET /` - 모든 팝업 조회 (관리자용)
  - `GET /active` - 현재 활성화된 팝업 조회 (사용자용)
  - `POST /` - 팝업 생성
  - `GET /<id>` - 팝업 상세 조회
  - `PUT /<id>` - 팝업 수정
  - `DELETE /<id>` - 팝업 삭제
- **관리자 모드**: "🔔 팝업 관리" 탭 추가
  - 팝업 등록/수정/삭제 기능
  - 이미지 업로드 기능
  - 팝업 사이즈 설정 (너비/높이)
- **사용자 모드**: 팝업 레이어 표시
  - 로그인 후 또는 페이지 로드 시 활성 팝업 자동 확인
  - 날짜 범위 내 활성화된 팝업만 표시
  - "닫기" 버튼: 일시적으로만 닫기
  - "하루 동안 보지 않기" 버튼: 오늘 하루 동안 표시하지 않음 (localStorage에 날짜와 함께 저장)

### 2. 화주사 정보 관리 기능
- **메뉴**: 화주사 모드 맨 왼쪽에 "👤 화주사 정보" 메뉴 추가
- **기능**:
  - 사업자 정보 조회/수정 (사업자번호, 대표명, 주소, 전화번호, 전자세금계산서 이메일)
  - 주소 검색: 우체국 Daum Postcode API 연동
  - 비밀번호 변경 기능
- **주소 저장 형식**: `우편번호|기본주소|상세주소`
- **API**: `/api/auth/my-info` (GET), `/api/auth/company-info` (PUT), `/api/auth/change-password` (POST)

### 3. 사업자 정보 미입력 배너
- **위치**: 화주사 모드 헤더 중앙 (고정 위치, 스크롤 따라감)
- **조건**: 사업자 정보가 모두 입력되지 않은 경우에만 표시
- **스타일**: 깜빡임 애니메이션, 오렌지 그라데이션 배경
- **메시지**: "⚠️ 화주사정보를 입력해주세요"

### 4. 게시판 기능
- **데이터베이스**: `board_categories`, `boards`, `board_files` 테이블
- **관리자 모드**: "📋 게시판 관리" 탭
  - 카테고리 관리 (접이식 메뉴)
  - 게시글 작성/수정/삭제
  - 파일 첨부 기능 (Cloudinary)
  - 공지사항 기능 (맨 위 고정, 굵은 글씨)
- **화주사 모드**: "📋 게시판" 메뉴
  - 카테고리별 필터링 (버튼 메뉴)
  - 테이블 형식 목록 표시
  - 게시글 상세 보기

### 5. 판매 스케쥴 기능
- **데이터베이스**: `schedules` 테이블
- **화주사 모드**: "📅 판매스케쥴" 메뉴
  - 스케쥴 등록/수정/삭제 (접이식 메뉴)
  - 스케쥴 목록 표시
  - 안내 설명 박스 (사전 신청 중요성)
- **관리자 모드**: "📅 스케쥴 관리" 탭
  - 달력 뷰 (화주사별 색상 구분)
  - 스케쥴 목록 표시
  - 관리자 스케쥴 등록 기능 (접이식 메뉴)
  - 스케쥴 삭제 기능

## 🔑 중요한 설정 정보

### 환경 변수
- **DATABASE_URL**: PostgreSQL 연결 문자열 (배포 시 필수)
  - **배포된 DATABASE_URL**: `postgresql://neondb_owner:npg_CNqVFs9j2Bpi@ep-dark-queen-a4w25otz-pooler.us-east-1.aws.neon.tech/neondb?sslmode=require`
  - ⚠️ **보안 주의**: 이 파일은 Git에 커밋되므로 비밀번호가 노출될 수 있습니다. 실제 운영 시에는 환경변수로만 관리하세요.
- **CLOUDINARY_CLOUD_NAME**: `dokk81rjh` (기본값)
- **CLOUDINARY_API_KEY**: `447577332396678` (기본값)
- **CLOUDINARY_API_SECRET**: `_fh-dOMoaFvOvCRkFk_AzqjOFA8` (기본값)
- **TELEGRAM_BOT_TOKEN**: (환경 변수로만 관리, 코드/문서에 저장하지 않음)
  - ⚠️ **보안 주의**: 토큰은 절대 코드나 문서에 저장하지 마세요. Vercel 환경 변수에만 저장하세요.

### 외부 Cron 잡 설정 (무료 대안) — 2025-11-17
- **배경**: Vercel Hobby 플랜은 Cron Jobs를 하루 1회만 허용하므로 5분 알림을 위해 `vercel.json`의 `crons` 설정을 제거함. (현재 `crons: []`)
- **대안**: 무료 서비스 cron-job.org를 사용해 `/api/cs/check-notifications` 엔드포인트를 주기적으로 호출.
- **환경 변수 추가**:
  1. Vercel → `Settings → Environment Variables`
  2. `CRON_SECRET` 생성 (예: `k7P3x9QwA2rL8s1V5tZ0nY4bC6mE7u`)
  3. Environment는 Production(필요 시 Preview/Development) 선택 후 저장
- **cron-job.org 설정 절차**:
  1. `Create Cronjob` → URL에 `https://3pl-return-management.vercel.app/api/cs/check-notifications`
  2. 주기: `Every 5 minutes`
  3. `Advanced` 탭
     - `Request method`: `POST`
     - Headers → `ADD`: `Authorization : Bearer <CRON_SECRET>`
     - Time zone: `Asia/Seoul`
  4. 저장 후 History 페이지에서 스케줄이 생성되었는지 확인
  5. 필요 시 주기를 일시적으로 1분으로 낮춰 동작 확인 후 되돌림
- **동작 확인**:
  - Vercel 로그에서 `🔄 [Cron] C/S 알림 체크 시작 (Vercel Cron Jobs)` 메시지가 보이면 성공
  - 텔레그램 미처리 알림이 5분 간격으로 오는지 모니터링

### 텔레그램 봇 설정
- **봇 토큰**: (Vercel 환경 변수에만 저장)
- **확인된 채팅방 ID**:
  - 개인 채팅방: `1926059537` (misteryoh)
  - 그룹 채팅방: `-4993829776` (jjay3pl 그룹)
- **봇 추가 방법**:
  1. 텔레그램 앱에서 봇 사용자명으로 검색 (BotFather가 제공한 사용자명)
  2. 봇을 클릭하여 대화 시작
  3. `/start` 명령어 전송
  4. 관리자 개인 채팅방 또는 그룹 채팅방에 봇 추가
- **채팅방 ID 확인 방법**:
  1. 봇에게 `/start` 메시지 전송
  2. 브라우저에서 접속: `https://api.telegram.org/bot{봇토큰}/getUpdates` (봇 토큰은 Vercel 환경 변수에서 확인)
  3. 응답 JSON에서 `"chat":{"id":숫자}` 값 확인
  4. 개인 채팅: `"chat":{"id":123456789}` → `TELEGRAM_CHAT_ID=123456789`
  5. 그룹 채팅: `"chat":{"id":-123456789}` → `TELEGRAM_CHAT_ID=-123456789` (음수)
- **환경 변수 설정** (Vercel):
  - `TELEGRAM_BOT_TOKEN`: (Vercel 환경 변수에 저장)
  - `TELEGRAM_CHAT_ID`: `-4993829776` (jjay3pl 그룹 사용 권장) 또는 `1926059537` (개인 채팅방)
- **Vercel 환경 변수 설정 방법** (상세):
  1. **Vercel 대시보드 접속**
     - https://vercel.com 접속 후 로그인
     - 프로젝트 선택 (`jjaysolution.com` 또는 `3pl-return-management`)
  
  2. **Settings 메뉴 클릭**
     - 프로젝트 대시보드 상단 메뉴에서 "Settings" 클릭
  
  3. **Environment Variables 메뉴 클릭**
     - 왼쪽 사이드바에서 "Environment Variables" 클릭
  
  4. **환경 변수 추가**
     - "Add New" 또는 "Add" 버튼 클릭
     - 첫 번째 변수 추가:
       - **Key**: `TELEGRAM_BOT_TOKEN`
       - **Value**: (새로 발급받은 토큰 입력)
       - **Environment**: Production, Preview, Development 모두 체크 (또는 Production만 체크)
       - "Save" 클릭
     - 두 번째 변수 추가:
       - **Key**: `TELEGRAM_CHAT_ID`
       - **Value**: `-4993829776` (그룹 채팅방) 또는 `1926059537` (개인 채팅방)
       - **Environment**: Production, Preview, Development 모두 체크 (또는 Production만 체크)
       - "Save" 클릭
  
  5. **배포 재시작** (중요!)
     - 환경 변수 추가 후 자동으로 재배포되지 않을 수 있음
     - "Deployments" 탭으로 이동
     - 최신 배포 항목의 "..." 메뉴 클릭
     - "Redeploy" 선택
     - 또는 코드를 약간 수정하고 푸시하여 자동 재배포 유도
  
  6. **환경 변수 확인**
     - 배포 후 로그에서 환경 변수가 제대로 로드되었는지 확인
     - 또는 코드에서 `os.environ.get('TELEGRAM_BOT_TOKEN')`로 확인

### 도메인 및 배포
- **도메인**: `jjaysolution.com` (Vercel에서 구매 및 연결 완료)
- **배포 플랫폼**: Vercel
- **저장소**: GitHub (`pyojungoh/3pl-return-management`)
- **브랜치**: `main` (자동 배포)

### 데이터베이스
- **로컬**: SQLite (`data.db`)
- **배포**: PostgreSQL/Neon (환경변수 `DATABASE_URL`)
- **마이그레이션**: 자동 (테이블이 없으면 생성, 컬럼 추가는 `ALTER TABLE` 시도)

## ⚠️ 주의사항

### ID 중복 문제
- **HTML 요소 ID는 반드시 고유해야 함**
- 같은 ID가 여러 곳에서 사용되면 `getElementById()`가 예상과 다른 요소를 반환할 수 있음
- **예시**: `popupTitle` ID가 레이어의 `<h2>`와 폼의 `<input>`에서 중복 사용됨 → `popupTitleInput`으로 변경
- **체크리스트**:
  - 새 요소 추가 시 기존 ID와 중복되지 않는지 확인
  - `grep`으로 ID 검색하여 중복 확인
  - JavaScript에서 요소를 찾을 때 정확한 ID 사용

### 배포 후 테스트 필수
- 로컬에서만 테스트하면 안 됨
- PostgreSQL 환경에서도 테스트 필요
- 특히 데이터베이스 스키마 변경 시 배포 후 확인 필수

### qrmobile 페이지 테스트 체크리스트
- [ ] QR 코드 스캔 기능 작동 확인
- [ ] 송장번호 직접 입력 후 검색 작동 확인
- [ ] 월 선택 및 데이터 조회 작동 확인
- [ ] 사진 업로드 기능 작동 확인 (Cloudinary 연동)
- [ ] 반품 등록 기능 작동 확인 (데이터베이스 저장)
- [ ] 화주사 등록 탭 작동 확인
- [ ] 비밀번호 변경 탭 작동 확인
- [ ] 모바일 기기에서 실제 테스트 (카메라 권한 포함)
- [ ] HTTPS 환경에서 카메라 접근 확인

---

## 📋 게시판 메뉴 코딩 가이드 (2025-11-14 추가)

### 🎯 개요
게시판 메뉴는 관리자와 화주사 모두 사용할 수 있는 게시글 관리 시스템입니다. Summernote 리치 텍스트 에디터를 사용하여 블로그 스타일의 게시글 작성이 가능합니다.

### 📁 관련 파일
- **프론트엔드**: `dashboard_server.html` (게시판 관리 탭)
- **백엔드 API**: `api/board/routes_db.py`
- **데이터베이스 모델**: `api/database/models.py` (게시판 관련 함수들)

### 🔧 주요 기능

#### 1. 게시글 작성/수정/삭제
- **Summernote 리치 텍스트 에디터** 사용
- 폰트, 크기, 색상, 이미지, 동영상 링크 등 지원
- 공지사항 체크 기능 (`is_pinned`)
- 카테고리 분류
- 첨부파일 업로드 (Cloudinary)

#### 2. 카테고리 관리
- 카테고리 생성/수정/삭제
- 카테고리별 게시글 필터링
- "공지사항" 카테고리 자동 인식

#### 3. 게시글 목록 표시
- 제목 스타일링 우선순위:
  1. **공지사항 체크 (`is_pinned`)**: 빨간색 굵은 글씨 + 📌 아이콘
  2. **공지사항 카테고리**: 굵은 글씨
  3. **나머지**: 일반 글씨
- 작성일 표시 (KST 기준)
- 조회수 표시

#### 4. 동영상 링크 자동 변환
- YouTube, Vimeo 링크를 자동으로 iframe으로 변환
- 직접 동영상 파일 링크도 `<video>` 태그로 변환

### 📝 프론트엔드 함수 목록 (`dashboard_server.html`)

#### 게시글 목록 관련
- `loadBoards()`: 전체 게시글 목록 로드
- `loadBoardPostsByCategoryFilter(categoryId)`: 카테고리 필터로 게시글 로드
- `loadBoardPostsByCategory(categoryId)`: 특정 카테고리 게시글 로드
- `showBoardDetail(boardId)`: 게시글 상세 보기

#### 게시글 작성/수정 관련
- `toggleBoardForm()`: 게시글 작성 폼 표시/숨김
- `resetBoardForm()`: 게시글 작성 폼 초기화
- `saveBoard()`: 새 게시글 저장
- `editBoard(boardId)`: 게시글 수정 모드로 전환
- `updateBoard(boardId)`: 게시글 수정 저장
- `deleteBoard(boardId)`: 게시글 삭제

#### 카테고리 관련
- `loadCategoriesForBoard()`: 카테고리 목록 로드 (드롭다운용)

#### 유틸리티
- `convertVideoLinks(html)`: HTML 내 동영상 링크를 iframe/video 태그로 변환

### 🔌 백엔드 API 엔드포인트 (`api/board/routes_db.py`)

#### 카테고리 API
- `GET /api/board/categories`: 모든 카테고리 조회
- `POST /api/board/categories`: 카테고리 생성
- `PUT /api/board/categories/<category_id>`: 카테고리 수정
- `DELETE /api/board/categories/<category_id>`: 카테고리 삭제

#### 게시글 API
- `GET /api/board/posts`: 게시글 목록 조회 (선택적 `category_id` 파라미터)
- `GET /api/board/posts/<post_id>`: 게시글 상세 조회 (조회수 자동 증가)
- `POST /api/board/posts`: 게시글 생성
- `PUT /api/board/posts/<post_id>`: 게시글 수정
- `DELETE /api/board/posts/<post_id>`: 게시글 삭제

#### 파일 업로드 API
- `POST /api/board/upload`: 게시글 첨부파일 업로드 (Cloudinary)

### 🗄️ 데이터베이스 함수 (`api/database/models.py`)

#### 카테고리 관련
- `create_board_category(name, display_order)`: 카테고리 생성
- `get_all_board_categories()`: 모든 카테고리 조회
- `update_board_category(category_id, name, display_order)`: 카테고리 수정
- `delete_board_category(category_id)`: 카테고리 삭제

#### 게시글 관련
- `create_board(board_data)`: 게시글 생성 (SQLite에서 ID 명시적 생성)
- `get_boards_by_category(category_id)`: 카테고리별 게시글 조회 (공지사항 우선 정렬)
- `get_all_boards()`: 모든 게시글 조회
- `get_board_by_id(board_id)`: 게시글 ID로 조회
- `update_board(board_id, board_data)`: 게시글 수정
- `delete_board(board_id)`: 게시글 삭제
- `increment_board_view_count(board_id)`: 조회수 증가

#### 첨부파일 관련
- `create_board_file(file_data)`: 첨부파일 정보 저장
- `get_board_files(board_id)`: 게시글 첨부파일 조회
- `delete_board_file(file_id)`: 첨부파일 삭제

### ⚠️ 중요 주의사항

#### 1. Summernote 에디터 초기화
- `toggleBoardForm()`에서 폼을 열 때 Summernote를 `destroy` 후 재초기화해야 함
- 이전 내용이 남지 않도록 `resetBoardForm()`에서 `summernote('code', '')`와 `summernote('reset')` 호출 필수
- 원본 textarea의 `value`도 직접 초기화 필요

#### 2. 게시글 수정 시 카테고리 설정
- `editBoard()` 함수에서 `await loadCategoriesForBoard()`를 **반드시 먼저 호출**해야 함
- 카테고리 드롭다운이 채워진 후에 `categorySelect.value`를 설정해야 함
- `setTimeout`으로 DOM 업데이트 대기 권장

#### 3. 공지사항 체크박스 설정
- `editBoard()`에서 `is_pinned` 값을 엄격하게 체크:
  ```javascript
  const isPinned = post.is_pinned === true || post.is_pinned === 1 || String(post.is_pinned) === '1';
  ```
- 문자열 '0', 숫자 0, false는 체크되지 않아야 함

#### 4. 게시글 ID 생성 (SQLite)
- SQLite에서는 `AUTOINCREMENT`가 항상 신뢰할 수 없으므로 명시적 ID 생성 필요
- `create_board()` 함수에서 `MAX(id) + 1` 방식으로 ID 생성
- 생성된 ID를 명시적으로 INSERT에 포함

#### 5. 제목 스타일링 로직
- `loadBoards()`, `loadBoardPostsByCategoryFilter()`, `loadBoardPostsByCategory()`에서 동일한 로직 적용
- `isPinned` 체크는 엄격하게: `post.is_pinned === true || post.is_pinned === 1 || String(post.is_pinned) === '1'`
- 카테고리명이 "공지사항"인지 확인: `categoryName === '공지사항'`

#### 6. 동영상 링크 변환
- `convertVideoLinks()` 함수는 `showBoardDetail()`에서 호출
- YouTube, Vimeo 링크를 자동 감지하여 반응형 iframe으로 변환
- 직접 동영상 파일 링크도 `<video>` 태그로 변환

#### 7. 작성일 표시
- `create_board()`에서 `created_at`을 KST 기준으로 명시적으로 저장
- `showBoardDetail()`에서 날짜 포맷팅 시 null 체크 필수

#### 8. 게시글 내용 렌더링
- Summernote로 작성된 HTML은 그대로 렌더링 (escapeHtml 사용 안 함)
- `showBoardDetail()`에서 `post.content`를 직접 HTML로 삽입

### 🐛 디버깅 팁

#### 게시글 ID가 null인 경우
1. `create_board()` 함수에서 ID 생성 로직 확인
2. SQLite Row 객체를 딕셔너리로 변환할 때 `id` 필드 추출 확인
3. 브라우저 콘솔에서 `post.id` 값 확인

#### 카테고리가 수정 시 따라오지 않는 경우
1. `editBoard()`에서 `await loadCategoriesForBoard()` 호출 확인
2. `setTimeout`으로 DOM 업데이트 대기 시간 확인
3. 브라우저 콘솔에서 카테고리 드롭다운 옵션 확인

#### 공지사항 체크박스가 모두 체크되는 경우
1. `is_pinned` 값의 타입 확인 (숫자 0, 문자열 '0' 등)
2. 엄격한 비교 연산자 사용 확인 (`===` 사용)
3. 브라우저 콘솔에서 `post.is_pinned` 값 확인

#### 동영상이 재생되지 않는 경우
1. `convertVideoLinks()` 함수가 호출되는지 확인
2. YouTube/Vimeo 링크 형식 확인
3. 브라우저 콘솔에서 변환된 HTML 확인

### 📚 참고 라이브러리
- **jQuery**: Summernote 의존성 (CDN: `https://code.jquery.com/jquery-3.6.0.min.js`)
- **Summernote**: 리치 텍스트 에디터 (CDN: `https://cdn.jsdelivr.net/npm/summernote@0.8.20/dist/summernote-lite.min.js`)
- **Cloudinary**: 이미지/파일 업로드 서비스

### 🔄 수정 시 체크리스트
- [ ] Summernote 에디터 초기화/리셋 로직 확인
- [ ] 카테고리 드롭다운 로드 타이밍 확인
- [ ] 공지사항 체크박스 엄격한 비교 확인
- [ ] 게시글 ID 생성 로직 확인 (SQLite)
- [ ] 제목 스타일링 우선순위 로직 확인
- [ ] 동영상 링크 변환 함수 호출 확인
- [ ] 작성일 KST 저장 확인
- [ ] 게시글 내용 HTML 렌더링 확인

---

## 📅 스케줄 관리 메뉴 코딩 가이드

### 🎯 "모든화주사" 스케줄 기능 규칙 (2025-11-14 추가)

#### 1. 기본 개념
- **"모든화주사" 타입 스케줄**: 관리자가 모든 화주사에게 일괄적으로 적용되는 공지사항 성격의 스케줄
- **데이터베이스 저장 방식**: 각 화주사마다 개별 스케줄 레코드로 저장 (화주사가 20개면 20개 레코드 생성)
- **표시 방식**: 프론트엔드에서 중복 제거하여 1개만 표시 (화주사명: "제이제이", 타입: "입고" 등)

#### 2. 스케줄 생성 규칙 (`api/schedules/routes_db.py` - `create_schedule_route`)

**관리자 모드에서 "모든 화주사" 선택 시:**
- 모든 비관리자 화주사를 조회 (`get_all_companies()`)
- 각 화주사마다 개별 스케줄 레코드 생성
- `company_name`: 각 화주사의 실제 이름으로 저장 (예: "보딩패스", "제이제이" 등)
- `schedule_type`: 
  - 사용자가 선택한 타입이 있으면: `"모든화주사-{타입}"` (예: `"모든화주사-입고"`)
  - 타입이 없으면: `"모든화주사"`
- 생성 결과: 화주사 수만큼 스케줄 레코드 생성 (예: 20개 화주사면 20개 레코드)

**일반 스케줄 생성:**
- 단일 화주사 선택 시: 해당 화주사 1개만 생성
- `company_name`: 선택한 화주사명
- `schedule_type`: 사용자가 선택한 타입 (입고, 출고, 행사, 연휴, 기타)

#### 3. 스케줄 표시 규칙 (`dashboard_server.html`)

**캘린더 표시 (`renderCalendar` 함수):**
- `schedule_type`이 "모든화주사"로 시작하는 스케줄은 중복 제거
- 같은 `title`, `start_date`, `end_date`를 가진 스케줄은 1개만 표시
- 표시 형식: `"제이제이(타입)"` (예: `"제이제이(입고)"`)
- `schedule_type`에서 "모든화주사-" 접두사 제거 후 표시

**목록 표시 (`renderScheduleListTable` 함수):**
- 캘린더와 동일한 중복 제거 로직 적용
- `company_name`을 "제이제이"로 표시
- `schedule_type`에서 "모든화주사-" 접두사 제거 후 표시

**모달 표시 (`showScheduleModal` 함수):**
- 동일한 접두사 제거 로직 적용
- `"화주사이름(타입)"` 형식으로 표시

#### 4. 스케줄 삭제 규칙 (`api/database/models.py` - `delete_schedule`)

**중요: 삭제는 권한(role)에 따라 다르게 동작**

**관리자 모드에서 삭제:**
- `schedule_type`이 "모든화주사"로 시작하는 경우:
  - 같은 `title`, `start_date`, `end_date`를 가진 **모든 화주사의 스케줄 일괄 삭제**
  - 예: 20개 화주사면 20개 모두 삭제
- 일반 스케줄: 해당 스케줄 1개만 삭제

**화주사 모드에서 삭제:**
- `schedule_type`이 "모든화주사"로 시작하는 경우:
  - **본인의 스케줄만 삭제** (다른 화주사는 유지)
  - 조건: `company_name = {본인 화주사명}` AND `title`, `start_date`, `end_date` 일치
- 일반 스케줄: 해당 스케줄 1개만 삭제

**삭제 API 호출 (`dashboard_server.html` - `deleteSchedule` 함수):**
- `role`과 `company`를 query parameter로 전달
- 예: `/api/schedules/delete/{id}?role=화주사&company=보딩패스`

#### 5. 스케줄 ID 생성 규칙 (`api/database/models.py` - `create_schedule`)

**SQLite 환경:**
- 랜덤 ID 생성 (타임스탬프 + 랜덤 숫자)
- 중복 체크 후 사용 가능한 ID 선택
- 모든 스케줄에 고유 ID 필수 (삭제 시 필요)

**PostgreSQL 환경:**
- `RETURNING id` 사용하여 자동 생성된 ID 반환

#### 6. 중복 제거 로직 (`dashboard_server.html`)

**Map/Set을 사용한 중복 제거:**
```javascript
// 키 생성: `${title}_${start_date}_${end_date}`
const key = `${schedule.title}_${schedule.start_date}_${schedule.end_date}`;
const allCompaniesSchedulesMap = new Map();
```

**조건:**
- `schedule_type`이 "모든화주사"로 시작하거나 "모든화주사"인 경우만 중복 제거
- 일반 스케줄은 모두 표시

#### 7. 스케줄 타입 종류
- **입고**: 입고 관련 스케줄
- **출고**: 출고 관련 스케줄
- **행사**: 행사 관련 스케줄
- **연휴**: 연휴 관련 스케줄
- **기타**: 기타 스케줄

#### 8. 주의사항

**절대 금지:**
- "모든화주사" 타입 스케줄을 화주사 모드에서 삭제할 때 다른 화주사의 스케줄까지 삭제하면 안 됨
- 관리자 모드에서 삭제할 때 일부만 삭제되면 안 됨 (모두 삭제되어야 함)

**필수 확인:**
- 삭제 API 호출 시 `role`과 `company` 파라미터 전달 확인
- `schedule_type` 체크 로직 정확성 확인
- 중복 제거 로직이 올바르게 작동하는지 확인

### 🔄 수정 시 체크리스트
- [ ] "모든화주사" 타입 스케줄 생성 시 모든 화주사에 개별 레코드 생성 확인
- [ ] `schedule_type`에 "모든화주사-" 접두사 정확히 추가 확인
- [ ] 캘린더/목록에서 중복 제거 로직 작동 확인
- [ ] 관리자 모드 삭제 시 모든 화주사 스케줄 일괄 삭제 확인
- [ ] 화주사 모드 삭제 시 본인 스케줄만 삭제 확인
- [ ] 삭제 API에 `role`과 `company` 파라미터 전달 확인
- [ ] 스케줄 ID 생성 로직 확인 (SQLite 랜덤 ID)
- [ ] 표시 형식 "제이제이(타입)" 확인


