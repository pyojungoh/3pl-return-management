# 프로젝트 작업 규칙 및 주의사항

## 🚨 최상위 작업 원칙 (모든 작업에 우선 적용)

### ⚠️ 기존 코드 수정 금지 원칙 (절대 원칙)
- **절대 금지**: 새로운 기능을 추가한다고 해서 기존 코드를 수정하면 안 됨
- **기존 파일 수정 금지 목록**:
  - ❌ `dashboard_server.html`의 기존 함수 수정 금지
  - ❌ `app.py`의 기존 라우트 수정 금지
  - ❌ `api/*/routes_db.py`의 기존 API 엔드포인트 수정 금지
  - ❌ `api/database/models.py`의 기존 함수 수정 금지
  - ❌ `index.html`의 기존 기능 수정 금지
- **허용되는 경우**:
  - ✅ 새로운 파일 생성 (예: `new_menu.html`, `api/new_menu/routes_db.py`)
  - ✅ `app.py`에 새로운 blueprint 등록만 추가
  - ✅ `dashboard_server.html`에 새로운 메뉴 버튼만 추가
  - ✅ 새로운 데이터베이스 테이블 생성 (기존 테이블 수정 금지)
- **작업 전 필수 확인**:
  - [ ] 기존 파일을 수정해야 하는지 다시 한 번 확인
  - [ ] 정말 새로운 파일로 분리할 수 없는지 확인
  - [ ] 기존 코드를 건드리지 않고도 구현 가능한지 확인

### 🧭 Git 워킹 트리 관리 규칙 (2025-11-20 추가)
- 항상 `git status -sb` 결과를 확인하고, 자신이 수정할 파일만 작업한다.
- **다른 사람이 작업 중인 파일은 절대 스테이징/커밋하지 말 것.**
  - 예: `api/cs/scheduler.py`, `api/uploads/cloudinary_upload.py`, `api/uploads/routes.py`, `data.db`와 같이 이미 수정된 파일은 읽기만 하고 손대지 않는다.
  - 사용자가 지정한 파일은 “보호 구역”으로 간주하고, 포맷팅·정리·주석 추가도 금지.
- 새 기능과 무관한 파일이 스테이징 되었으면 즉시 `git reset <파일>`로 제외한다.
- 커밋 직전에 `git diff --cached`로 실제 커밋 대상 파일을 재확인한다.

### 새로운 메뉴/기능 모듈화 원칙 (필수)
- **기존 메뉴/기능**: 그대로 유지, 수정하지 않음
- **새로운 메뉴/기능**: 반드시 모듈화하여 독립적인 파일로 관리
  - 한 페이지에 모든 코드가 몰리지 않도록 분리
  - HTML, CSS, JavaScript를 별도 파일로 분리하거나 최소한 함수 단위로 명확히 구분
  - 수정이 용이하도록 독립적인 모듈로 구성
  - 각 모듈은 자체적으로 완결성을 가져야 함
- **예시 구조**:
  ```
  새로운 메뉴 추가 시:
  - HTML: 별도 파일 (예: new_menu.html)
  - CSS: 별도 스타일 블록 또는 별도 파일
  - JavaScript: 별도 함수 그룹 (접두사 사용, 예: nmInit, nmLoad 등)
  - API: 별도 라우트 파일 (api/new_menu/routes_db.py)
  - 데이터베이스: 새로운 테이블만 생성 (기존 테이블 수정 금지)
  ```
- **작업 전 체크리스트**:
  - [ ] 새로운 메뉴/기능인지 확인 (기존 메뉴 수정이 아닌지)
  - [ ] 모듈화 계획 수립 (파일 구조, 함수 분리)
  - [ ] 기존 코드와의 충돌 여부 확인
  - [ ] **기존 파일을 수정하지 않고도 구현 가능한지 확인**
  - [ ] 새로운 파일명과 함수명이 기존 것과 충돌하지 않는지 확인
- **작업 후 체크리스트**:
  - [ ] 독립적인 모듈로 완성되었는지 확인
  - [ ] 기존 기능에 영향을 주지 않는지 확인
  - [ ] 재사용 가능한 구조인지 확인
  - [ ] **기존 파일이 수정되지 않았는지 확인 (git diff로 확인)**
  - [ ] **기존 기능이 정상 작동하는지 테스트**

## 🛡️ 기존 코드 보호 전략

### 1. Git 브랜치 전략 (권장)
- **새 기능 작업 시**: 별도 브랜치 생성
  ```bash
  git checkout -b feature/new-menu-name
  # 작업 완료 후
  git checkout main
  git merge feature/new-menu-name
  ```
- **장점**: 문제 발생 시 쉽게 롤백 가능
- **주의**: 브랜치 작업 후 반드시 main 브랜치에서 테스트

### 2. 코드 수정 전 확인 절차
- **1단계: 기존 코드 검색**
  ```bash
  # 수정하려는 함수/변수명이 어디에 사용되는지 확인
  grep -r "함수명" .
  grep -r "변수명" .
  ```
- **2단계: 영향 범위 파악**
  - 수정하려는 코드가 다른 곳에서 사용되는지 확인
  - 사용되는 곳이 있으면 수정 금지
- **3단계: 대안 검토**
  - 기존 코드를 수정하지 않고도 구현 가능한 방법 찾기
  - 새로운 함수/파일로 분리할 수 있는지 확인

### 3. ID/함수명 충돌 방지
- **HTML 요소 ID**: 고유한 접두사 사용
  - 예: `nmContainer`, `nmButton`, `nmTable` (nm = new menu)
  - 기존 ID와 충돌하지 않는지 `grep`으로 확인
- **JavaScript 함수명**: 고유한 접두사 사용
  - 예: `nmInit()`, `nmLoad()`, `nmRender()` (nm = new menu)
  - 기존 함수명과 충돌하지 않는지 `grep`으로 확인
- **CSS 클래스명**: 고유한 접두사 사용
  - 예: `.nm-container`, `.nm-button`, `.nm-table`
  - 기존 클래스명과 충돌하지 않는지 `grep`으로 확인

### 4. 테스트 전 필수 확인
- **기존 기능 테스트** (새 기능 작업 전):
  - [ ] 로그인 기능 정상 작동
  - [ ] 반품 등록/조회 정상 작동
  - [ ] 기존 메뉴들이 정상 작동
  - [ ] 모바일 페이지 정상 작동
- **새 기능 작업 후**:
  - [ ] 위의 기존 기능들이 여전히 정상 작동하는지 재확인
  - [ ] 새 기능만 테스트하는 것이 아니라 전체 시스템 테스트

### 5. 롤백 계획
- **문제 발생 시 즉시 롤백**:
  ```bash
  # 마지막 커밋 취소
  git reset --hard HEAD~1
  # 또는 특정 커밋으로 되돌리기
  git reset --hard <commit-hash>
  ```
- **배포 전 확인**: 로컬에서 모든 기능 테스트 완료 후 배포

## ⛔ 하지 말아야 할 것들

1. **터미널 명령어 실행**
   - 이제부터 터미널 명령어를 직접 실행할 수 있음
   - 배포 작업 시 git 명령어를 직접 실행 가능
   - 필요시 사용자에게 확인 후 실행

2. **불필요한 .md 파일 생성 금지**
   - 설명 문서나 가이드 파일을 만들지 말 것
   - 사용자가 명시적으로 요청한 경우만 생성

3. **명령어를 하나의 코드 블록에 묶지 말 것**
   - 각 명령어를 개별 코드 블록으로 제공
   - 복사하기 편하도록 하나씩 따로 제공

4. **Railway 관련 작업 금지**
   - 이 프로젝트는 GitHub + Vercel을 사용
   - Railway 관련 파일이나 설정 제안하지 말 것

5. **Git 커밋 메시지 인코딩 문제 방지**
   - ⚠️ **절대 금지**: Git 커밋 메시지에 한글을 사용하면 안 됨
   - 한글 커밋 메시지는 인코딩 문제로 푸시가 실패하거나 깨질 수 있음
   - **반드시 영문으로만 커밋 메시지 작성**
   - 예시:
     - ❌ 잘못된 예: `git commit -m "사업자 정보 필수 팝업 모달 추가"`
     - ✅ 올바른 예: `git commit -m "Add business info required modal popup"`
   - 커밋 메시지 형식:
     - 동사로 시작 (Add, Fix, Update, Remove, Refactor 등)
     - 간결하고 명확하게 작성
     - 필요시 여러 줄로 상세 설명 추가 가능

## ✅ 수정 시 주의사항

### 0. ⚠️ 새로운 기능 추가 시 기존 기능 유지 (최우선 원칙)
- **절대 금지**: 새로운 기능을 추가한다고 해서 기존 기능이 사라지거나 작동하지 않게 만들면 안 됨
- **절대 금지**: 기존 파일을 수정하여 새 기능을 추가하면 안 됨
- **원칙**: 새 기능은 반드시 새로운 파일로 분리하여 추가
- **절대 금지**: 새로운 기능을 추가한다고 해서 기존 기능이 사라지거나 작동하지 않게 만들면 안 됨
- **기존 기능 목록** (반드시 유지해야 할 기능들):
  1. **인증 기능** (`api/auth/routes_db.py`):
     - 로그인 (`/api/auth/login`)
     - 화주사 등록 (`/api/auth/register`)
     - 비밀번호 변경 (`/api/auth/change-password`)
     - 화주사 정보 조회/수정 (`/api/auth/my-info`, `/api/auth/company-info`)
     - 화주사 목록 조회 (`/api/auth/companies`)
  2. **반품 관리 기능** (`api/returns/routes_db.py`):
     - 반품 등록 (`/api/returns/create`)
     - 반품 목록 조회 (`/api/returns/data`)
     - 반품 상세 조회 (`/api/returns/<id>`)
     - 반품 수정/삭제 (`/api/returns/<id>`)
     - 완료 처리 (`/api/returns/<id>/complete`)
     - 메모 저장 (`/api/returns/<id>/memo`)
     - 월별 데이터 조회 (`/api/returns/available-months`)
     - CSV 내보내기 (`/api/returns/export`)
  3. **이미지 업로드 기능** (`api/uploads/routes.py`):
     - 이미지 업로드 (`/api/uploads/upload-images`)
     - 송장번호로 검색 (`/api/uploads/find-by-tracking`)
  4. **모바일 페이지** (`index.html`):
     - QR 코드 스캔 기능
     - 송장번호 검색
     - 반품 등록
     - 사진 업로드
     - 화주사 등록
     - 비밀번호 변경
  5. **대시보드** (`dashboard_server.html`):
     - 관리자 모드 (반품 관리, 화주사 관리, 게시판 관리, 스케쥴 관리, 팝업 관리)
     - 화주사 모드 (반품 조회, 게시판, 판매스케쥴, 화주사 정보)
     - 로그인 기능
     - F5 새로고침 시 메뉴/탭 유지
  6. **게시판 기능** (`api/board/routes_db.py`):
     - 게시글 작성/수정/삭제
     - 카테고리 관리
     - 파일 첨부
  7. **스케쥴 기능** (`api/schedules/routes_db.py`):
     - 스케쥴 등록/수정/삭제
     - 달력 뷰
  8. **팝업 기능** (`api/popups/routes_db.py`):
     - 팝업 등록/수정/삭제
     - 활성 팝업 조회
- **작업 전 체크리스트**:
  - [ ] 새 기능 추가 전에 기존 기능 목록 확인
  - [ ] 기존 API 엔드포인트가 변경되지 않는지 확인
  - [ ] 기존 HTML 요소나 JavaScript 함수가 삭제되지 않는지 확인
  - [ ] 기존 데이터베이스 테이블이나 컬럼이 삭제되지 않는지 확인
  - [ ] 기존 파일이 삭제되거나 이름이 변경되지 않는지 확인
- **작업 후 체크리스트**:
  - [ ] 모든 기존 기능이 정상 작동하는지 테스트
  - [ ] 기존 API 엔드포인트가 여전히 작동하는지 확인
  - [ ] 기존 페이지가 정상적으로 로드되는지 확인
  - [ ] 기존 데이터가 정상적으로 조회/수정되는지 확인
- **주의사항**:
  - 기존 코드를 수정할 때는 최소한의 변경만 수행
  - 기존 함수나 API를 삭제하지 말고, 필요시 확장만 수행
  - 기존 HTML 요소를 삭제하지 말고, 필요시 새로운 요소만 추가
  - 기존 데이터베이스 스키마를 변경할 때는 하위 호환성 유지

### 1. 파일 삭제 시 확인
- 실제 사용 중인 파일인지 반드시 확인
- `__init__.py` 파일들이 올바른 모듈을 import하는지 확인
- `app.py`에서 사용하는 파일인지 확인

### 2. 데이터베이스 호환성
- **로컬**: SQLite 사용 (`data.db`)
- **배포 (Vercel)**: PostgreSQL/Neon 사용
- 두 환경 모두 지원하도록 코드 작성

### 3. Import 에러 방지
- SQLite 모드: `from sqlite3 import OperationalError, IntegrityError`
- PostgreSQL 모드: `from psycopg2 import IntegrityError, OperationalError`
- `api/database/models.py`에서 두 가지 모두 import 필요

### 4. __init__.py 파일 확인
- `api/auth/__init__.py`: `from .routes_db import auth_bp` (routes.py 아님)
- `api/returns/__init__.py`: `from .routes_db import returns_bp` (routes.py 아님)
- 파일 삭제 후 반드시 확인 필요

### 5. 메인 파일
- **HTML**: `dashboard_server.html` (메인 파일)
- `dashboard.html`, `dashboard_simple.html` 등은 삭제됨
- `app.py`는 `dashboard_server.html`만 사용

### 6. 모바일 페이지 (매우 중요)
- **파일**: `index.html` (QR 모바일 페이지)
- **라우트**: `/qrmobile`, `/admin` (레거시 경로)
- **중요도**: ⭐⭐⭐⭐⭐ (최우선)
  - 실제 물류 현장에서 사용하는 핵심 페이지
  - 반품 등록 및 사진 업로드의 주요 진입점
  - 이 페이지가 작동하지 않으면 현장 업무가 중단됨
- **주요 기능**:
  1. **QR 코드 스캔**: jsQR 라이브러리 사용, 카메라로 송장번호 자동 인식
  2. **송장번호 검색**: `/api/uploads/find-by-tracking` API 사용
  3. **반품 등록**: `/api/returns/create` API로 데이터 저장
  4. **사진 업로드**: `/api/uploads/upload-images` API로 Cloudinary 업로드
  5. **화주사 등록**: `/api/auth/register` API 사용
  6. **비밀번호 변경**: `/api/auth/change-password` API 사용
  7. **월별 데이터 조회**: `/api/returns/available-months` API 사용
- **작동 방식**:
  - 모바일 최적화 (반응형 디자인, 터치 친화적)
  - QR 코드 스캔 → 송장번호 자동 입력 → 데이터 검색 → 사진 업로드 → 반품 등록
  - HTTPS 필수 (카메라 접근을 위해)
  - 월 선택 후 해당 월의 데이터에서만 검색 (없으면 모든 월에서 검색)
- **주의사항**:
  - **절대 삭제하면 안 됨** - 현장 업무 중단
  - 파일 수정 시 반드시 테스트 필요 (QR 스캔, 사진 업로드, 데이터 저장)
  - 카메라 권한 요청 처리 필수
  - 모바일 브라우저 호환성 확인 필요
  - API 엔드포인트 변경 시 이 페이지도 함께 수정 필요

## 🎯 새로운 작업 규칙 (2025-11-14 추가)

### 1. 모듈화 원칙
- ⚠️ **최상위 작업 원칙 참조**: 새로운 메뉴/기능 모듈화 원칙은 상단의 "🚨 최상위 작업 원칙" 섹션을 반드시 준수
- **기존 코딩은 그대로 유지**: 기존에 작성된 코드는 수정하지 않고 그대로 유지
- **새로운 메뉴는 모듈화**: 새롭게 추가되는 메뉴들은 반드시 모듈화하여 코딩
  - 한 페이지에 모든 코드가 몰리지 않도록 분리
  - 수정이 용이하도록 독립적인 모듈로 구성
  - 예시: 새로운 메뉴의 HTML, CSS, JavaScript를 별도 파일로 분리하거나, 최소한 함수 단위로 명확히 구분

### 2. 리스트 순번 규칙
- **새로운 리스트 생성 시**: 항상 맨 앞에 순번(번호) 컬럼이 들어가야 함
  - 첫 번째 컬럼은 항상 순번
  - 순번은 1부터 시작하여 순차적으로 증가
  - 예시: `<th>순번</th><th>이름</th><th>날짜</th>...`

### 3. 리스트 가운데 정렬 규칙
- **모든 리스트**: 항상 가운데 정렬되어야 함
  - 테이블 헤더(`<th>`): `text-align: center;`
  - 테이블 데이터(`<td>`): `text-align: center;`
  - 리스트 아이템: 중앙 정렬 스타일 적용

### 4. F5 새로고침 시 메뉴 유지 규칙
- **새로운 메뉴 추가 시 필수**: F5 새로고침을 눌러도 해당 메뉴에서 새로고침되어야 함
  - 다른 메뉴로 이동되면 안 됨
  - 현재 활성화된 메뉴/탭이 유지되어야 함
- **구현 방법**:
  - 메뉴/탭 전환 시 `localStorage`에 현재 메뉴/탭 저장
  - 페이지 로드 시 `localStorage`에서 저장된 메뉴/탭 복원
  - 관리자 모드: `localStorage.setItem('activeAdminTab', tabName)`
  - 화주사 모드: `localStorage.setItem('activeConsignorMenu', menuName)`
- **체크리스트** (새 메뉴 추가 후):
  - [ ] 메뉴 전환 시 localStorage에 저장되는지 확인
  - [ ] F5 새로고침 후 해당 메뉴가 유지되는지 확인
  - [ ] 다른 메뉴로 이동 후 F5 새로고침 시 해당 메뉴가 유지되는지 확인

## 📋 프로젝트 구조

### 주요 파일
- `app.py`: Flask 메인 서버
- `dashboard_server.html`: 메인 대시보드 (로그인 + 관리 화면)
- `index.html`: **QR 모바일 페이지** (매우 중요 - 현장 업무 핵심)
- `api/database/models.py`: 데이터베이스 모델 (SQLite/PostgreSQL 호환)
- `api/auth/routes_db.py`: 인증 API (로그인, 회원가입)
- `api/returns/routes_db.py`: 반품 데이터 API
- `api/admin/routes.py`: 관리자 API (CSV 마이그레이션 등)
- `api/uploads/routes.py`: 이미지 업로드 API

### 데이터베이스
- 로컬: SQLite (`data.db`)
- 배포: PostgreSQL/Neon (환경변수 `DATABASE_URL`)
- **배포 DB 테이블 생성 규칙 (2025-11-26 추가)**  
  - 배포 환경에 새 테이블이 필요하면 *반드시 파이썬 스크립트 방식*으로 생성한다. (psql/GUI 직접 수정 금지)  
  - 절차:
    1. 프로젝트 루트에 `create_<table_name>.py`를 임시 생성한다. (Git에 커밋 금지)  
    2. `psycopg2.connect("postgresql://...neondb?sslmode=require")` 로 접속한 뒤 `CREATE TABLE IF NOT EXISTS ...` 와 필요한 기본 `INSERT` 문을 작성한다.  
    3. CMD에서 `cd c:\3plsolution` 후 `python create_<table_name>.py` 실행.  
    4. “테이블 생성 완료” 로그 확인 후 기능 테스트 → 스크립트 삭제.  
  - 작업 보고 시 “파이썬 스크립트 방식으로 테이블 생성 완료”라고 명시한다.

### 배포
- GitHub에 푸시
- Vercel 자동 배포
- 환경변수: `DATABASE_URL` (PostgreSQL 연결 문자열)
- 도메인: `jjaysolution.com` (Vercel에서 구매 및 연결 완료)

## 🔧 일반적인 작업 흐름

### 코드 수정 후 배포
1. 수정 완료
2. 터미널 명령어 직접 실행 (git add, commit, push)
3. Vercel 자동 배포 대기

### 파일 삭제 시 체크리스트
- [ ] `app.py`에서 import하는지 확인
- [ ] `__init__.py`에서 import하는지 확인
- [ ] 다른 파일에서 사용하는지 확인 (grep으로 검색)
- [ ] 삭제 후 관련 import 경로 수정

### 데이터베이스 관련 수정 시
- [ ] SQLite와 PostgreSQL 모두 테스트
- [ ] `OperationalError`, `IntegrityError` import 확인
- [ ] 환경변수 `DATABASE_URL` 확인

## 🚨 자주 발생하는 오류

### 1. ModuleNotFoundError
- `__init__.py`에서 삭제된 파일을 import하는 경우
- 해결: `routes_db.py`로 변경

### 2. NameError: name 'OperationalError' is not defined
- SQLite 모드에서 `OperationalError` import 누락
- 해결: `from sqlite3 import OperationalError, IntegrityError` 추가

### 3. 화주사 등록 오류
- None 값에 `.strip()` 호출
- 해결: None 체크 후 처리

### 4. 화주사 데이터 필터링 문제
- 관리자는 모든 데이터, 화주사는 자신의 데이터만
- 해결: `company` 파라미터로 필터링

## 📝 기타 주의사항

1. **언어**: 항상 한국어로 응답
2. **터미널 명령어**: 필요시 직접 실행 가능 (git 배포 등)
3. **파일 삭제**: 신중하게 확인 후 삭제
4. **에러 처리**: 상세한 로그 추가하여 디버깅 용이하게
5. **코드 수정**: 기존 기능을 깨뜨리지 않도록 주의
6. **기존 기능 유지**: 새로운 기능 추가 시 기존 기능이 사라지면 안 됨 (최우선 원칙)

## 🔄 작업 시 확인 사항

1. **기존 기능 유지 확인** (최우선):
   - [ ] 새로운 기능 추가 시 기존 기능이 사라지지 않았는지 확인
   - [ ] 기존 API 엔드포인트가 정상 작동하는지 확인
   - [ ] 기존 페이지가 정상적으로 로드되는지 확인
   - [ ] 기존 데이터가 정상적으로 조회/수정되는지 확인
2. 로컬에서 테스트 가능한지
3. 배포 후에도 작동하는지
4. SQLite와 PostgreSQL 모두 지원하는지
5. 기존 기능이 깨지지 않았는지
6. 에러 처리가 적절한지

## 📌 중요 기능 규칙

### 홈 버튼 기능 (로고 및 통합관리시스템 클릭)
- **위치**: 헤더 왼쪽 상단 (로고 이미지 및 "통합 관리 시스템" 텍스트)
- **기능**: 클릭 시 게시판 메뉴로 이동
  - 관리자 모드: 게시판 관리 탭으로 이동 (`switchAdminTab('board')`)
  - 화주사 모드: 게시판 메뉴로 이동 (`switchMenu('board')`)
- **구현**: `goToHome()` 함수 사용
- **적용 범위**: 관리자 및 화주사 모드 모두 적용

### 화주사 로그인 시 초기 메뉴 결정 규칙
- **기본 규칙**: 화주사는 로그인 시 최초 항상 게시판 메뉴로 이동
- **예외 규칙**: 화주사 정보가 입력되지 않은 경우 화주사 정보 메뉴로 이동
  - 화주사 정보 입력 여부 확인 기준:
    - 사업자번호 (`business_number`)
    - 대표명 (`business_name`)
    - 주소 (`business_address`)
    - 전화번호 (`business_tel`)
    - 이메일 (`business_email`)
  - 위 5개 필드가 모두 입력되어 있어야 화주사 정보가 입력된 것으로 간주
- **구현**: `checkCompanyInfoAndNavigate()` 함수 사용
- **우선순위**:
  1. 화주사 정보 미입력 → 화주사 정보 메뉴로 이동
  2. 화주사 정보 입력 완료 → 게시판 메뉴로 이동 (기본값)
  3. 저장된 메뉴가 있으면 저장된 메뉴로 이동 (F5 새로고침 시)

### F5 새로고침 시 현재 메뉴/탭 유지
- **관리자 모드**: `localStorage.setItem('activeAdminTab', tabName)` - 현재 활성 탭 저장
- **화주사 모드**: `localStorage.setItem('activeConsignorMenu', menuName)` - 현재 활성 메뉴 저장
- **복원 로직**: 페이지 로드 시 `localStorage.getItem()`으로 저장된 값 복원
- **기본값**: 저장된 값이 없으면 관리자는 'returns', 화주사는 'returns' 메뉴로 이동
- **주의사항**: 어떤 메뉴가 추가되어도 반드시 이 규칙을 따라야 함
  - 메뉴/탭 전환 시 localStorage에 저장
  - 페이지 로드 시 저장된 값으로 복원
  - 새로고침(F5) 후에도 현재 메뉴/탭이 유지되어야 함
- **⚠️ 새로운 메뉴/탭 추가 시 필수 작업 (반드시 확인)**:
  1. **메뉴 전환 함수에 localStorage 저장 추가**:
     - 화주사 모드: `switchMenu()` 함수에서 `localStorage.setItem('activeConsignorMenu', menuName)` 추가 확인
     - 관리자 모드: `switchAdminTab()` 함수에서 `localStorage.setItem('activeAdminTab', tabName)` 추가 확인
  2. **페이지 로드 시 복원 로직 추가**:
     - 화주사 모드: `showDashboard()` 함수에서 `localStorage.getItem('activeConsignorMenu')`로 저장된 메뉴 복원 확인
     - 관리자 모드: `showDashboard()` 함수에서 `localStorage.getItem('activeAdminTab')`로 저장된 탭 복원 확인
     - `validTabs` 또는 `validMenus` 배열에 새로운 메뉴/탭 이름 추가 확인
  3. **검증 리스트 (새로운 메뉴 추가 후 반드시 테스트)**:
     - [ ] 새로운 메뉴/탭 전환 시 localStorage에 저장되는지 확인
     - [ ] F5 새로고침 후 해당 메뉴/탭이 유지되는지 확인
     - [ ] 다른 메뉴로 이동 후 F5 새로고침 시 해당 메뉴가 유지되는지 확인
     - [ ] 로그아웃 후 다시 로그인 시 기본 메뉴로 이동하는지 확인

## 🖼️ 이미지 호스팅 정보

### Cloudinary 설정
- **서비스**: Cloudinary (이미지/파일 호스팅)
- **Cloud Name**: `dokk81rjh`
- **API Key**: `447577332396678`
- **API Secret**: `_fh-dOMoaFvOvCRkFk_AzqjOFA8`
- **설정 파일**: `api/uploads/cloudinary_upload.py`
- **환경 변수** (선택사항):
  - `CLOUDINARY_CLOUD_NAME`
  - `CLOUDINARY_API_KEY`
  - `CLOUDINARY_API_SECRET`

### 로고 URL
- **현재 사용 중인 로고 URL**: `https://res.cloudinary.com/dokk81rjh/image/upload/v1762922695/logo_srff9i.png`
- **위치**: `dashboard_server.html` (헤더 로고)
- **설정 위치**: `dashboard_server.html` 1393줄

### Cloudinary 업로드 폴더 구조
- **반품 내역 이미지**: `반품내역/년월/송장번호_타임스탬프_번호`
- **사업자 등록증**: `business_certificates/파일명_타임스탬프`
- **게시판 첨부파일**: `board_files/파일명`
- **팝업 이미지**: `board_files/파일명` (게시판 업로드 API 재사용)

### 주요 함수
- `upload_images_to_cloudinary()`: 반품 내역 이미지 업로드
- `upload_single_file_to_cloudinary()`: 단일 파일 업로드 (사업자 등록증 등)
- `upload_to_cloudinary()`: 일반 파일 업로드 (게시판, 팝업 등)

## 📸 사진 업로드 기능 가이드 (매우 중요)

### ⚠️ 주의사항
- **사진 업로드 기능은 매우 중요한 기능입니다**
- 코드 수정 시 사진 업로드가 막히는 경우가 자주 발생함
- 아래 가이드를 반드시 따라야 함
- 수정 후 반드시 테스트 필요

### 🔑 핵심 원칙

#### 1. 프론트엔드 (index.html) - 이미지 업로드 처리
- **위치**: `index.html`의 `submitForm()` 함수
- **핵심 코드 구조**:
  ```javascript
  // 1. 응답 상태 코드 확인 필수
  .then(response => {
    console.log('📥 이미지 업로드 응답 상태:', response.status, response.statusText);
    
    // 2. JSON 응답인지 확인 필수
    const contentType = response.headers.get('content-type');
    if (!contentType || !contentType.includes('application/json')) {
      return response.text().then(text => {
        console.error('❌ JSON이 아닌 응답:', text);
        throw new Error(`서버 오류 (${response.status}): ${text.substring(0, 200)}`);
      });
    }
    
    // 3. JSON 파싱
    return response.json().then(data => {
      console.log('📦 이미지 업로드 응답 데이터:', data);
      
      // 4. HTTP 상태 코드 확인 필수
      if (!response.ok) {
        throw new Error(data.message || `서버 오류 (${response.status})`);
      }
      
      // 5. success 필드 확인
      if (data.success) {
        // 성공 처리
      } else {
        throw new Error(data.message || '이미지 업로드 실패');
      }
    });
  })
  .catch(error => {
    // 6. 에러 처리 필수 (네트워크 오류 포함)
    console.error('❌ 이미지 업로드 오류:', error);
    // 에러 메시지 개선 필요
  });
  ```

#### 2. 서버 측 (api/uploads/routes.py) - 에러 처리
- **위치**: `api/uploads/routes.py`의 `upload_images()` 함수
- **핵심 코드 구조**:
  ```python
  @uploads_bp.route('/upload-images', methods=['POST'])
  def upload_images():
      try:
          # 1. 요청 로그 출력 필수
          print(f"📤 이미지 업로드 API 호출됨")
          print(f"   요청 URL: {request.url}")
          print(f"   Content-Type: {request.content_type}")
          
          # 2. JSON 데이터 확인 필수
          if not request.is_json:
              return jsonify({
                  'success': False,
                  'message': 'JSON 형식의 데이터가 필요합니다.'
              }), 400
          
          data = request.get_json()
          if not data:
              return jsonify({
                  'success': False,
                  'message': '요청 데이터가 없습니다.'
              }), 400
          
          # 3. 필수 필드 확인
          images = data.get('images', [])
          tracking_number = data.get('trackingNumber', '').strip()
          
          if not images or len(images) == 0:
              return jsonify({
                  'success': False,
                  'message': '이미지 데이터가 없습니다.'
              }), 400
          
          # 4. Cloudinary 업로드 (별도 try-except로 감싸기)
          try:
              photo_links = upload_images_to_drive(images, tracking_number)
              
              if not photo_links:
                  return jsonify({
                      'success': False,
                      'message': '이미지 업로드는 완료되었지만 링크를 가져올 수 없습니다.'
                  }), 500
              
              return jsonify({
                  'success': True,
                  'photoLinks': photo_links,
                  'message': f'{len(images)}장의 이미지가 업로드되었습니다.'
              })
          except Exception as upload_error:
              # 5. Cloudinary 오류 처리 (상세 로그 + 에러 메시지 개선)
              print(f"❌ Cloudinary 업로드 오류: {upload_error}")
              import traceback
              traceback.print_exc()
              
              # 에러 메시지 개선
              error_message = str(upload_error)
              if 'Cloudinary 설정' in error_message or '인증' in error_message:
                  error_message = 'Cloudinary 설정 오류: 환경 변수를 확인해주세요.'
              elif 'unauthorized' in error_message.lower() or '401' in error_message:
                  error_message = 'Cloudinary 인증 오류: API 키를 확인해주세요.'
              
              return jsonify({
                  'success': False,
                  'message': f'이미지 업로드 실패: {error_message}'
              }), 500
      
      except Exception as e:
          # 6. 전체 오류 처리 (상세 로그)
          print(f'❌ 이미지 업로드 API 오류: {e}')
          import traceback
          traceback.print_exc()
          return jsonify({
              'success': False,
              'message': f'이미지 업로드 실패: {str(e)}'
          }), 500
  ```

### ✅ 체크리스트 (코드 수정 시 반드시 확인)

#### 프론트엔드 체크리스트
- [ ] `response.ok` 또는 `response.status` 확인하는가?
- [ ] JSON 응답인지 `content-type` 확인하는가?
- [ ] `response.json()` 호출 전에 에러 처리하는가?
- [ ] `data.success` 필드 확인하는가?
- [ ] 네트워크 오류(`TypeError`, `fetch` 관련) 처리하는가?
- [ ] 콘솔 로그가 충분한가? (`📤`, `📥`, `📦`, `✅`, `❌`)
- [ ] 에러 메시지가 사용자에게 명확한가?

#### 서버 측 체크리스트
- [ ] 요청 로그가 충분한가? (요청 URL, Content-Type, 이미지 개수, 송장번호)
- [ ] `request.is_json` 확인하는가?
- [ ] `request.get_json()` 결과가 None인지 확인하는가?
- [ ] 필수 필드(`images`, `trackingNumber`) 확인하는가?
- [ ] Cloudinary 업로드를 별도 try-except로 감싸는가?
- [ ] Cloudinary 오류 시 상세 로그(`traceback.print_exc()`) 출력하는가?
- [ ] 에러 메시지를 사용자 친화적으로 개선하는가?
- [ ] HTTP 상태 코드를 적절히 반환하는가? (400, 500 등)

### 🚨 자주 발생하는 문제와 해결 방법

#### 1. 사진 업로드가 막히는 문제
- **원인**: `response.json()`을 바로 호출하고 `response.ok`를 확인하지 않음
- **해결**: 
  1. `response.status` 확인
  2. `content-type` 확인
  3. `response.ok` 확인 후 JSON 파싱

#### 2. 에러 메시지가 표시되지 않는 문제
- **원인**: 네트워크 오류나 JSON 파싱 오류를 catch하지 않음
- **해결**: 
  1. `response.text()`로 먼저 읽기 (JSON이 아닌 경우)
  2. `catch` 블록에서 모든 에러 처리
  3. 에러 타입별로 메시지 개선

#### 3. Cloudinary 업로드는 성공했지만 저장이 안 되는 문제
- **원인**: `photo_links`가 빈 문자열이거나 None
- **해결**: 
  1. `photo_links` 확인 후 저장
  2. 빈 문자열 체크 추가
  3. 업로드 후 링크 개수 확인

#### 4. 서버 오류가 클라이언트에 전달되지 않는 문제
- **원인**: 서버에서 상세 로그를 출력하지 않음
- **해결**: 
  1. 모든 단계에서 `print()` 로그 출력
  2. `traceback.print_exc()` 사용
  3. 에러 메시지를 명확하게 작성

### 📝 수정 시 따라야 할 순서

1. **프론트엔드 수정 시**:
   - `index.html`의 `submitForm()` 함수 확인
   - 위의 "프론트엔드 체크리스트" 확인
   - 콘솔 로그 확인
   - 실제 모바일에서 테스트

2. **서버 측 수정 시**:
   - `api/uploads/routes.py`의 `upload_images()` 함수 확인
   - 위의 "서버 측 체크리스트" 확인
   - Vercel 로그 확인
   - 실제 업로드 테스트

3. **수정 후 확인**:
   - 로컬에서 테스트
   - 배포 후 실제 모바일에서 테스트
   - 콘솔 로그와 서버 로그 확인
   - 에러 발생 시 즉시 롤백 고려

### 🔍 디버깅 방법

1. **브라우저 콘솔 확인**:
   - `📤 이미지 업로드 시작`
   - `📥 이미지 업로드 응답 상태`
   - `📦 이미지 업로드 응답 데이터`
   - `❌ 이미지 업로드 오류`

2. **서버 로그 확인 (Vercel)**:
   - `📤 이미지 업로드 API 호출됨`
   - `📸 Cloudinary 업로드 시작`
   - `✅ Cloudinary 업로드 완료`
   - `❌ Cloudinary 업로드 오류`

3. **네트워크 탭 확인**:
   - 요청 URL 확인
   - 요청 헤더 확인
   - 응답 상태 코드 확인
   - 응답 본문 확인

## 🚧 현재 미해결 문제

### 팝업 저장 오류 (2025-11-12)
- **문제**: 팝업 관리에서 저장 버튼 클릭 시 저장이 안 되는 문제
- **증상**: 
  - 콘솔 로그에서 `title` 필드가 빈 문자열로 표시됨
  - "모든 필드를 입력해주세요" 에러 메시지 표시
  - 실제로는 모든 필드가 입력되어 있음
- **원인 분석**:
  - `popupTitle` ID가 두 곳에서 사용됨:
    1. 팝업 레이어의 제목 표시용 `<h2 id="popupTitle">` (1424줄)
    2. 팝업 폼의 입력 필드 `<input type="text" id="popupTitle">` (2054줄 → 수정됨)
  - `getElementById('popupTitle')`이 레이어의 `<h2>` 요소를 먼저 반환
  - `<h2>` 요소는 `value` 속성이 없어 빈 문자열 반환
- **시도한 해결 방법**:
  - 폼의 input 필드 ID를 `popupTitleInput`으로 변경 (2054줄)
  - 관련 JavaScript 함수 모두 업데이트:
    - `savePopup()` - 저장 함수
    - `resetPopupForm()` - 폼 초기화 함수
    - `editPopup()` - 수정 함수
- **현재 상태**: 
  - 코드 수정 완료 및 푸시 완료 (커밋: `89de436`)
  - **아직 테스트 미완료** - 내일 다시 확인 필요
- **다음 단계**:
  1. 배포 후 실제로 저장이 되는지 확인
  2. 콘솔 로그에서 `title` 값이 제대로 읽히는지 확인
  3. 여전히 문제가 있으면 추가 디버깅 필요

## 📋 최근 추가된 기능 (2025-11-12)

### 1. 팝업 관리 기능
- **데이터베이스**: `popups` 테이블 추가
  - 필드: `id`, `title`, `content`, `image_url`, `width`, `height`, `start_date`, `end_date`, `is_active`, `created_at`, `updated_at`
- **API 라우트**: `/api/popups/`
  - `GET /` - 모든 팝업 조회 (관리자용)
  - `GET /active` - 현재 활성화된 팝업 조회 (사용자용)
  - `POST /` - 팝업 생성
  - `GET /<id>` - 팝업 상세 조회
  - `PUT /<id>` - 팝업 수정
  - `DELETE /<id>` - 팝업 삭제
- **관리자 모드**: "🔔 팝업 관리" 탭 추가
  - 팝업 등록/수정/삭제 기능
  - 이미지 업로드 기능
  - 팝업 사이즈 설정 (너비/높이)
- **사용자 모드**: 팝업 레이어 표시
  - 로그인 후 또는 페이지 로드 시 활성 팝업 자동 확인
  - 날짜 범위 내 활성화된 팝업만 표시
  - "닫기" 버튼: 일시적으로만 닫기
  - "하루 동안 보지 않기" 버튼: 오늘 하루 동안 표시하지 않음 (localStorage에 날짜와 함께 저장)

### 2. 화주사 정보 관리 기능
- **메뉴**: 화주사 모드 맨 왼쪽에 "👤 화주사 정보" 메뉴 추가
- **기능**:
  - 사업자 정보 조회/수정 (사업자번호, 대표명, 주소, 전화번호, 전자세금계산서 이메일)
  - 주소 검색: 우체국 Daum Postcode API 연동
  - 비밀번호 변경 기능
- **주소 저장 형식**: `우편번호|기본주소|상세주소`
- **API**: `/api/auth/my-info` (GET), `/api/auth/company-info` (PUT), `/api/auth/change-password` (POST)

### 3. 사업자 정보 미입력 배너
- **위치**: 화주사 모드 헤더 중앙 (고정 위치, 스크롤 따라감)
- **조건**: 사업자 정보가 모두 입력되지 않은 경우에만 표시
- **스타일**: 깜빡임 애니메이션, 오렌지 그라데이션 배경
- **메시지**: "⚠️ 화주사정보를 입력해주세요"

### 4. 게시판 기능
- **데이터베이스**: `board_categories`, `boards`, `board_files` 테이블
- **관리자 모드**: "📋 게시판 관리" 탭
  - 카테고리 관리 (접이식 메뉴)
  - 게시글 작성/수정/삭제
  - 파일 첨부 기능 (Cloudinary)
  - 공지사항 기능 (맨 위 고정, 굵은 글씨)
- **화주사 모드**: "📋 게시판" 메뉴
  - 카테고리별 필터링 (버튼 메뉴)
  - 테이블 형식 목록 표시
  - 게시글 상세 보기

### 5. 판매 스케쥴 기능
- **데이터베이스**: `schedules` 테이블
- **화주사 모드**: "📅 판매스케쥴" 메뉴
  - 스케쥴 등록/수정/삭제 (접이식 메뉴)
  - 스케쥴 목록 표시
  - 안내 설명 박스 (사전 신청 중요성)
- **관리자 모드**: "📅 스케쥴 관리" 탭
  - 달력 뷰 (화주사별 색상 구분)
  - 스케쥴 목록 표시
  - 관리자 스케쥴 등록 기능 (접이식 메뉴)
  - 스케쥴 삭제 기능

## 🔑 중요한 설정 정보

### 환경 변수
- **DATABASE_URL**: PostgreSQL 연결 문자열 (배포 시 필수)
  - **배포된 DATABASE_URL**: `postgresql://neondb_owner:npg_CNqVFs9j2Bpi@ep-dark-queen-a4w25otz-pooler.us-east-1.aws.neon.tech/neondb?sslmode=require`
  - ⚠️ **보안 주의**: 이 파일은 Git에 커밋되므로 비밀번호가 노출될 수 있습니다. 실제 운영 시에는 환경변수로만 관리하세요.
- **CLOUDINARY_CLOUD_NAME**: `dokk81rjh` (기본값)
- **CLOUDINARY_API_KEY**: `447577332396678` (기본값)
- **CLOUDINARY_API_SECRET**: `_fh-dOMoaFvOvCRkFk_AzqjOFA8` (기본값)
- **TELEGRAM_BOT_TOKEN**: (환경 변수로만 관리, 코드/문서에 저장하지 않음)
  - ⚠️ **보안 주의**: 토큰은 절대 코드나 문서에 저장하지 마세요. Vercel 환경 변수에만 저장하세요.

### 외부 Cron 잡 설정 (무료 대안) — 2025-11-17
- **배경**: Vercel Hobby 플랜은 Cron Jobs를 하루 1회만 허용하므로 5분 알림을 위해 `vercel.json`의 `crons` 설정을 제거함. (현재 `crons: []`)
- **대안**: 무료 서비스 cron-job.org를 사용해 `/api/cs/check-notifications` 엔드포인트를 주기적으로 호출.
- **환경 변수 추가**:
  1. Vercel → `Settings → Environment Variables`
  2. `CRON_SECRET` 생성 (예: `k7P3x9QwA2rL8s1V5tZ0nY4bC6mE7u`)
  3. Environment는 Production(필요 시 Preview/Development) 선택 후 저장
- **cron-job.org 설정 절차**:
  1. `Create Cronjob` → URL에 `https://3pl-return-management.vercel.app/api/cs/check-notifications`
  2. 주기: `Every 5 minutes`
  3. `Advanced` 탭
     - `Request method`: `POST`
     - Headers → `ADD`: `Authorization : Bearer <CRON_SECRET>`
     - Time zone: `Asia/Seoul`
  4. 저장 후 History 페이지에서 스케줄이 생성되었는지 확인
  5. 필요 시 주기를 일시적으로 1분으로 낮춰 동작 확인 후 되돌림
- **동작 확인**:
  - Vercel 로그에서 `🔄 [Cron] C/S 알림 체크 시작 (Vercel Cron Jobs)` 메시지가 보이면 성공
  - 텔레그램 미처리 알림이 5분 간격으로 오는지 모니터링

### 텔레그램 봇 설정
- **봇 토큰**: (Vercel 환경 변수에만 저장)
- **확인된 채팅방 ID**:
  - 개인 채팅방: `1926059537` (misteryoh)
  - 그룹 채팅방: `-4993829776` (jjay3pl 그룹)
- **봇 추가 방법**:
  1. 텔레그램 앱에서 봇 사용자명으로 검색 (BotFather가 제공한 사용자명)
  2. 봇을 클릭하여 대화 시작
  3. `/start` 명령어 전송
  4. 관리자 개인 채팅방 또는 그룹 채팅방에 봇 추가
- **채팅방 ID 확인 방법**:
  1. 봇에게 `/start` 메시지 전송
  2. 브라우저에서 접속: `https://api.telegram.org/bot{봇토큰}/getUpdates` (봇 토큰은 Vercel 환경 변수에서 확인)
  3. 응답 JSON에서 `"chat":{"id":숫자}` 값 확인
  4. 개인 채팅: `"chat":{"id":123456789}` → `TELEGRAM_CHAT_ID=123456789`
  5. 그룹 채팅: `"chat":{"id":-123456789}` → `TELEGRAM_CHAT_ID=-123456789` (음수)
- **환경 변수 설정** (Vercel):
  - `TELEGRAM_BOT_TOKEN`: (Vercel 환경 변수에 저장)
  - `TELEGRAM_CHAT_ID`: `-4993829776` (jjay3pl 그룹 사용 권장) 또는 `1926059537` (개인 채팅방)
- **Vercel 환경 변수 설정 방법** (상세):
  1. **Vercel 대시보드 접속**
     - https://vercel.com 접속 후 로그인
     - 프로젝트 선택 (`jjaysolution.com` 또는 `3pl-return-management`)
  
  2. **Settings 메뉴 클릭**
     - 프로젝트 대시보드 상단 메뉴에서 "Settings" 클릭
  
  3. **Environment Variables 메뉴 클릭**
     - 왼쪽 사이드바에서 "Environment Variables" 클릭
  
  4. **환경 변수 추가**
     - "Add New" 또는 "Add" 버튼 클릭
     - 첫 번째 변수 추가:
       - **Key**: `TELEGRAM_BOT_TOKEN`
       - **Value**: (새로 발급받은 토큰 입력)
       - **Environment**: Production, Preview, Development 모두 체크 (또는 Production만 체크)
       - "Save" 클릭
     - 두 번째 변수 추가:
       - **Key**: `TELEGRAM_CHAT_ID`
       - **Value**: `-4993829776` (그룹 채팅방) 또는 `1926059537` (개인 채팅방)
       - **Environment**: Production, Preview, Development 모두 체크 (또는 Production만 체크)
       - "Save" 클릭
  
  5. **배포 재시작** (중요!)
     - 환경 변수 추가 후 자동으로 재배포되지 않을 수 있음
     - "Deployments" 탭으로 이동
     - 최신 배포 항목의 "..." 메뉴 클릭
     - "Redeploy" 선택
     - 또는 코드를 약간 수정하고 푸시하여 자동 재배포 유도
  
  6. **환경 변수 확인**
     - 배포 후 로그에서 환경 변수가 제대로 로드되었는지 확인
     - 또는 코드에서 `os.environ.get('TELEGRAM_BOT_TOKEN')`로 확인

### 도메인 및 배포
- **도메인**: `jjaysolution.com` (Vercel에서 구매 및 연결 완료)
- **배포 플랫폼**: Vercel
- **저장소**: GitHub (`pyojungoh/3pl-return-management`)
- **브랜치**: `main` (자동 배포)

### 데이터베이스
- **로컬**: SQLite (`data.db`)
- **배포**: PostgreSQL/Neon (환경변수 `DATABASE_URL`)
- **마이그레이션**: 자동 (테이블이 없으면 생성, 컬럼 추가는 `ALTER TABLE` 시도)

## ⚠️ 주의사항

### ID 중복 문제
- **HTML 요소 ID는 반드시 고유해야 함**
- 같은 ID가 여러 곳에서 사용되면 `getElementById()`가 예상과 다른 요소를 반환할 수 있음
- **예시**: `popupTitle` ID가 레이어의 `<h2>`와 폼의 `<input>`에서 중복 사용됨 → `popupTitleInput`으로 변경
- **체크리스트**:
  - 새 요소 추가 시 기존 ID와 중복되지 않는지 확인
  - `grep`으로 ID 검색하여 중복 확인
  - JavaScript에서 요소를 찾을 때 정확한 ID 사용

### 배포 후 테스트 필수
- 로컬에서만 테스트하면 안 됨
- PostgreSQL 환경에서도 테스트 필요
- 특히 데이터베이스 스키마 변경 시 배포 후 확인 필수

### qrmobile 페이지 테스트 체크리스트
- [ ] QR 코드 스캔 기능 작동 확인
- [ ] 송장번호 직접 입력 후 검색 작동 확인
- [ ] 월 선택 및 데이터 조회 작동 확인
- [ ] 사진 업로드 기능 작동 확인 (Cloudinary 연동)
- [ ] 반품 등록 기능 작동 확인 (데이터베이스 저장)
- [ ] 화주사 등록 탭 작동 확인
- [ ] 비밀번호 변경 탭 작동 확인
- [ ] 모바일 기기에서 실제 테스트 (카메라 권한 포함)
- [ ] HTTPS 환경에서 카메라 접근 확인

---

## 📋 게시판 메뉴 코딩 가이드 (2025-11-14 추가)

### 🎯 개요
게시판 메뉴는 관리자와 화주사 모두 사용할 수 있는 게시글 관리 시스템입니다. Summernote 리치 텍스트 에디터를 사용하여 블로그 스타일의 게시글 작성이 가능합니다.

### 📁 관련 파일
- **프론트엔드**: `dashboard_server.html` (게시판 관리 탭)
- **백엔드 API**: `api/board/routes_db.py`
- **데이터베이스 모델**: `api/database/models.py` (게시판 관련 함수들)

### 🔧 주요 기능

#### 1. 게시글 작성/수정/삭제
- **Summernote 리치 텍스트 에디터** 사용
- 폰트, 크기, 색상, 이미지, 동영상 링크 등 지원
- 공지사항 체크 기능 (`is_pinned`)
- 카테고리 분류
- 첨부파일 업로드 (Cloudinary)

#### 2. 카테고리 관리
- 카테고리 생성/수정/삭제
- 카테고리별 게시글 필터링
- "공지사항" 카테고리 자동 인식

#### 3. 게시글 목록 표시
- 제목 스타일링 우선순위:
  1. **공지사항 체크 (`is_pinned`)**: 빨간색 굵은 글씨 + 📌 아이콘
  2. **공지사항 카테고리**: 굵은 글씨
  3. **나머지**: 일반 글씨
- 작성일 표시 (KST 기준)
- 조회수 표시

#### 4. 동영상 링크 자동 변환
- YouTube, Vimeo 링크를 자동으로 iframe으로 변환
- 직접 동영상 파일 링크도 `<video>` 태그로 변환

### 📝 프론트엔드 함수 목록 (`dashboard_server.html`)

#### 게시글 목록 관련
- `loadBoards()`: 전체 게시글 목록 로드
- `loadBoardPostsByCategoryFilter(categoryId)`: 카테고리 필터로 게시글 로드
- `loadBoardPostsByCategory(categoryId)`: 특정 카테고리 게시글 로드
- `showBoardDetail(boardId)`: 게시글 상세 보기

#### 게시글 작성/수정 관련
- `toggleBoardForm()`: 게시글 작성 폼 표시/숨김
- `resetBoardForm()`: 게시글 작성 폼 초기화
- `saveBoard()`: 새 게시글 저장
- `editBoard(boardId)`: 게시글 수정 모드로 전환
- `updateBoard(boardId)`: 게시글 수정 저장
- `deleteBoard(boardId)`: 게시글 삭제

#### 카테고리 관련
- `loadCategoriesForBoard()`: 카테고리 목록 로드 (드롭다운용)

#### 유틸리티
- `convertVideoLinks(html)`: HTML 내 동영상 링크를 iframe/video 태그로 변환

### 🔌 백엔드 API 엔드포인트 (`api/board/routes_db.py`)

#### 카테고리 API
- `GET /api/board/categories`: 모든 카테고리 조회
- `POST /api/board/categories`: 카테고리 생성
- `PUT /api/board/categories/<category_id>`: 카테고리 수정
- `DELETE /api/board/categories/<category_id>`: 카테고리 삭제

#### 게시글 API
- `GET /api/board/posts`: 게시글 목록 조회 (선택적 `category_id` 파라미터)
- `GET /api/board/posts/<post_id>`: 게시글 상세 조회 (조회수 자동 증가)
- `POST /api/board/posts`: 게시글 생성
- `PUT /api/board/posts/<post_id>`: 게시글 수정
- `DELETE /api/board/posts/<post_id>`: 게시글 삭제

#### 파일 업로드 API
- `POST /api/board/upload`: 게시글 첨부파일 업로드 (Cloudinary)

### 🗄️ 데이터베이스 함수 (`api/database/models.py`)

#### 카테고리 관련
- `create_board_category(name, display_order)`: 카테고리 생성
- `get_all_board_categories()`: 모든 카테고리 조회
- `update_board_category(category_id, name, display_order)`: 카테고리 수정
- `delete_board_category(category_id)`: 카테고리 삭제

#### 게시글 관련
- `create_board(board_data)`: 게시글 생성 (SQLite에서 ID 명시적 생성)
- `get_boards_by_category(category_id)`: 카테고리별 게시글 조회 (공지사항 우선 정렬)
- `get_all_boards()`: 모든 게시글 조회
- `get_board_by_id(board_id)`: 게시글 ID로 조회
- `update_board(board_id, board_data)`: 게시글 수정
- `delete_board(board_id)`: 게시글 삭제
- `increment_board_view_count(board_id)`: 조회수 증가

#### 첨부파일 관련
- `create_board_file(file_data)`: 첨부파일 정보 저장
- `get_board_files(board_id)`: 게시글 첨부파일 조회
- `delete_board_file(file_id)`: 첨부파일 삭제

### ⚠️ 중요 주의사항

#### 1. Summernote 에디터 초기화
- `toggleBoardForm()`에서 폼을 열 때 Summernote를 `destroy` 후 재초기화해야 함
- 이전 내용이 남지 않도록 `resetBoardForm()`에서 `summernote('code', '')`와 `summernote('reset')` 호출 필수
- 원본 textarea의 `value`도 직접 초기화 필요

#### 2. 게시글 수정 시 카테고리 설정
- `editBoard()` 함수에서 `await loadCategoriesForBoard()`를 **반드시 먼저 호출**해야 함
- 카테고리 드롭다운이 채워진 후에 `categorySelect.value`를 설정해야 함
- `setTimeout`으로 DOM 업데이트 대기 권장

#### 3. 공지사항 체크박스 설정
- `editBoard()`에서 `is_pinned` 값을 엄격하게 체크:
  ```javascript
  const isPinned = post.is_pinned === true || post.is_pinned === 1 || String(post.is_pinned) === '1';
  ```
- 문자열 '0', 숫자 0, false는 체크되지 않아야 함

#### 4. 게시글 ID 생성 (SQLite)
- SQLite에서는 `AUTOINCREMENT`가 항상 신뢰할 수 없으므로 명시적 ID 생성 필요
- `create_board()` 함수에서 `MAX(id) + 1` 방식으로 ID 생성
- 생성된 ID를 명시적으로 INSERT에 포함

#### 5. 제목 스타일링 로직
- `loadBoards()`, `loadBoardPostsByCategoryFilter()`, `loadBoardPostsByCategory()`에서 동일한 로직 적용
- `isPinned` 체크는 엄격하게: `post.is_pinned === true || post.is_pinned === 1 || String(post.is_pinned) === '1'`
- 카테고리명이 "공지사항"인지 확인: `categoryName === '공지사항'`

#### 6. 동영상 링크 변환
- `convertVideoLinks()` 함수는 `showBoardDetail()`에서 호출
- YouTube, Vimeo 링크를 자동 감지하여 반응형 iframe으로 변환
- 직접 동영상 파일 링크도 `<video>` 태그로 변환

#### 7. 작성일 표시
- `create_board()`에서 `created_at`을 KST 기준으로 명시적으로 저장
- `showBoardDetail()`에서 날짜 포맷팅 시 null 체크 필수

#### 8. 게시글 내용 렌더링
- Summernote로 작성된 HTML은 그대로 렌더링 (escapeHtml 사용 안 함)
- `showBoardDetail()`에서 `post.content`를 직접 HTML로 삽입

### 🐛 디버깅 팁

#### 게시글 ID가 null인 경우
1. `create_board()` 함수에서 ID 생성 로직 확인
2. SQLite Row 객체를 딕셔너리로 변환할 때 `id` 필드 추출 확인
3. 브라우저 콘솔에서 `post.id` 값 확인

#### 카테고리가 수정 시 따라오지 않는 경우
1. `editBoard()`에서 `await loadCategoriesForBoard()` 호출 확인
2. `setTimeout`으로 DOM 업데이트 대기 시간 확인
3. 브라우저 콘솔에서 카테고리 드롭다운 옵션 확인

#### 공지사항 체크박스가 모두 체크되는 경우
1. `is_pinned` 값의 타입 확인 (숫자 0, 문자열 '0' 등)
2. 엄격한 비교 연산자 사용 확인 (`===` 사용)
3. 브라우저 콘솔에서 `post.is_pinned` 값 확인

#### 동영상이 재생되지 않는 경우
1. `convertVideoLinks()` 함수가 호출되는지 확인
2. YouTube/Vimeo 링크 형식 확인
3. 브라우저 콘솔에서 변환된 HTML 확인

### 📚 참고 라이브러리
- **jQuery**: Summernote 의존성 (CDN: `https://code.jquery.com/jquery-3.6.0.min.js`)
- **Summernote**: 리치 텍스트 에디터 (CDN: `https://cdn.jsdelivr.net/npm/summernote@0.8.20/dist/summernote-lite.min.js`)
- **Cloudinary**: 이미지/파일 업로드 서비스

### 🔄 수정 시 체크리스트
- [ ] Summernote 에디터 초기화/리셋 로직 확인
- [ ] 카테고리 드롭다운 로드 타이밍 확인
- [ ] 공지사항 체크박스 엄격한 비교 확인
- [ ] 게시글 ID 생성 로직 확인 (SQLite)
- [ ] 제목 스타일링 우선순위 로직 확인
- [ ] 동영상 링크 변환 함수 호출 확인
- [ ] 작성일 KST 저장 확인
- [ ] 게시글 내용 HTML 렌더링 확인

---

## 📅 스케줄 관리 메뉴 코딩 가이드

### 🎯 "모든화주사" 스케줄 기능 규칙 (2025-11-14 추가)

#### 1. 기본 개념
- **"모든화주사" 타입 스케줄**: 관리자가 모든 화주사에게 일괄적으로 적용되는 공지사항 성격의 스케줄
- **데이터베이스 저장 방식**: 각 화주사마다 개별 스케줄 레코드로 저장 (화주사가 20개면 20개 레코드 생성)
- **표시 방식**: 프론트엔드에서 중복 제거하여 1개만 표시 (화주사명: "제이제이", 타입: "입고" 등)

#### 2. 스케줄 생성 규칙 (`api/schedules/routes_db.py` - `create_schedule_route`)

**관리자 모드에서 "모든 화주사" 선택 시:**
- 모든 비관리자 화주사를 조회 (`get_all_companies()`)
- 각 화주사마다 개별 스케줄 레코드 생성
- `company_name`: 각 화주사의 실제 이름으로 저장 (예: "보딩패스", "제이제이" 등)
- `schedule_type`: 
  - 사용자가 선택한 타입이 있으면: `"모든화주사-{타입}"` (예: `"모든화주사-입고"`)
  - 타입이 없으면: `"모든화주사"`
- 생성 결과: 화주사 수만큼 스케줄 레코드 생성 (예: 20개 화주사면 20개 레코드)

**일반 스케줄 생성:**
- 단일 화주사 선택 시: 해당 화주사 1개만 생성
- `company_name`: 선택한 화주사명
- `schedule_type`: 사용자가 선택한 타입 (입고, 출고, 행사, 연휴, 기타)

#### 3. 스케줄 표시 규칙 (`dashboard_server.html`)

**캘린더 표시 (`renderCalendar` 함수):**
- `schedule_type`이 "모든화주사"로 시작하는 스케줄은 중복 제거
- 같은 `title`, `start_date`, `end_date`를 가진 스케줄은 1개만 표시
- 표시 형식: `"제이제이(타입)"` (예: `"제이제이(입고)"`)
- `schedule_type`에서 "모든화주사-" 접두사 제거 후 표시

**목록 표시 (`renderScheduleListTable` 함수):**
- 캘린더와 동일한 중복 제거 로직 적용
- `company_name`을 "제이제이"로 표시
- `schedule_type`에서 "모든화주사-" 접두사 제거 후 표시

**모달 표시 (`showScheduleModal` 함수):**
- 동일한 접두사 제거 로직 적용
- `"화주사이름(타입)"` 형식으로 표시

#### 4. 스케줄 삭제 규칙 (`api/database/models.py` - `delete_schedule`)

**중요: 삭제는 권한(role)에 따라 다르게 동작**

**관리자 모드에서 삭제:**
- `schedule_type`이 "모든화주사"로 시작하는 경우:
  - 같은 `title`, `start_date`, `end_date`를 가진 **모든 화주사의 스케줄 일괄 삭제**
  - 예: 20개 화주사면 20개 모두 삭제
- 일반 스케줄: 해당 스케줄 1개만 삭제

**화주사 모드에서 삭제:**
- `schedule_type`이 "모든화주사"로 시작하는 경우:
  - **본인의 스케줄만 삭제** (다른 화주사는 유지)
  - 조건: `company_name = {본인 화주사명}` AND `title`, `start_date`, `end_date` 일치
- 일반 스케줄: 해당 스케줄 1개만 삭제

**삭제 API 호출 (`dashboard_server.html` - `deleteSchedule` 함수):**
- `role`과 `company`를 query parameter로 전달
- 예: `/api/schedules/delete/{id}?role=화주사&company=보딩패스`

#### 5. 스케줄 ID 생성 규칙 (`api/database/models.py` - `create_schedule`)

**SQLite 환경:**
- 랜덤 ID 생성 (타임스탬프 + 랜덤 숫자)
- 중복 체크 후 사용 가능한 ID 선택
- 모든 스케줄에 고유 ID 필수 (삭제 시 필요)

**PostgreSQL 환경:**
- `RETURNING id` 사용하여 자동 생성된 ID 반환

#### 6. 중복 제거 로직 (`dashboard_server.html`)

**Map/Set을 사용한 중복 제거:**
```javascript
// 키 생성: `${title}_${start_date}_${end_date}`
const key = `${schedule.title}_${schedule.start_date}_${schedule.end_date}`;
const allCompaniesSchedulesMap = new Map();
```

**조건:**
- `schedule_type`이 "모든화주사"로 시작하거나 "모든화주사"인 경우만 중복 제거
- 일반 스케줄은 모두 표시

#### 7. 스케줄 타입 종류
- **입고**: 입고 관련 스케줄
- **출고**: 출고 관련 스케줄
- **행사**: 행사 관련 스케줄
- **연휴**: 연휴 관련 스케줄
- **기타**: 기타 스케줄

#### 8. 주의사항

**절대 금지:**
- "모든화주사" 타입 스케줄을 화주사 모드에서 삭제할 때 다른 화주사의 스케줄까지 삭제하면 안 됨
- 관리자 모드에서 삭제할 때 일부만 삭제되면 안 됨 (모두 삭제되어야 함)

**필수 확인:**
- 삭제 API 호출 시 `role`과 `company` 파라미터 전달 확인
- `schedule_type` 체크 로직 정확성 확인
- 중복 제거 로직이 올바르게 작동하는지 확인

### 🔄 수정 시 체크리스트
- [ ] "모든화주사" 타입 스케줄 생성 시 모든 화주사에 개별 레코드 생성 확인
- [ ] `schedule_type`에 "모든화주사-" 접두사 정확히 추가 확인
- [ ] 캘린더/목록에서 중복 제거 로직 작동 확인
- [ ] 관리자 모드 삭제 시 모든 화주사 스케줄 일괄 삭제 확인
- [ ] 화주사 모드 삭제 시 본인 스케줄만 삭제 확인
- [ ] 삭제 API에 `role`과 `company` 파라미터 전달 확인
- [ ] 스케줄 ID 생성 로직 확인 (SQLite 랜덤 ID)
- [ ] 표시 형식 "제이제이(타입)" 확인

---

## 🔒 기존 코드 수정 금지 가이드 (2025-01-20 추가)

### ⚠️ 핵심 원칙
**새로운 기능을 추가할 때는 절대 기존 코드를 수정하지 않는다.**

### 📋 작업 전 필수 체크리스트

#### 1. 기존 코드 수정 필요성 확인
- [ ] **정말 기존 파일을 수정해야 하는가?**
  - 새로운 파일로 분리할 수 없는가?
  - 기존 함수를 수정하지 않고 새로운 함수를 만들 수 없는가?
  - 기존 HTML 요소를 수정하지 않고 새로운 요소를 추가할 수 없는가?
- [ ] **기존 코드 수정이 필수인 경우**:
  - 왜 필수인지 명확한 이유 작성
  - 사용자에게 수정 이유 설명 및 승인 요청
  - 수정 범위를 최소화할 수 있는 방법 검토

#### 2. 충돌 확인
- [ ] **ID 충돌 확인**:
  ```bash
  grep -r "새로운ID" dashboard_server.html
  grep -r "새로운ID" index.html
  ```
- [ ] **함수명 충돌 확인**:
  ```bash
  grep -r "새로운함수명" dashboard_server.html
  ```
- [ ] **CSS 클래스명 충돌 확인**:
  ```bash
  grep -r "새로운클래스명" dashboard_server.html
  ```

#### 3. 모듈화 계획 수립
- [ ] **새로운 파일 생성 계획**:
  - HTML 파일: `new_menu.html` (별도 파일)
  - API 파일: `api/new_menu/routes_db.py` (새 디렉토리)
  - JavaScript 함수: `nmInit()`, `nmLoad()` 등 (접두사 사용)
- [ ] **기존 파일과의 연결 방법**:
  - `dashboard_server.html`에 메뉴 버튼만 추가 (기존 함수 수정 금지)
  - `app.py`에 blueprint 등록만 추가 (기존 라우트 수정 금지)
  - AJAX로 새 HTML 파일 로드 (기존 HTML 수정 금지)

### 📝 작업 중 주의사항

#### 1. 기존 파일 수정 금지 목록
- ❌ `dashboard_server.html`의 기존 함수 수정 금지
- ❌ `dashboard_server.html`의 기존 HTML 구조 수정 금지
- ❌ `app.py`의 기존 라우트 수정 금지
- ❌ `api/*/routes_db.py`의 기존 API 엔드포인트 수정 금지
- ❌ `api/database/models.py`의 기존 함수 수정 금지
- ❌ `index.html`의 기존 기능 수정 금지

#### 2. 허용되는 작업
- ✅ 새로운 파일 생성
- ✅ `app.py`에 새로운 blueprint 등록 추가
- ✅ `dashboard_server.html`에 새로운 메뉴 버튼 추가
- ✅ `dashboard_server.html`에 새로운 JavaScript 함수 추가 (기존 함수 수정 금지)
- ✅ 새로운 데이터베이스 테이블 생성

#### 3. 코드 작성 규칙
- **함수명 접두사 사용**: 새 기능의 모든 함수에 고유한 접두사 사용
  - 예: 특수작업 → `swInit()`, `swLoad()`, `swRender()`
  - 예: 새 메뉴 → `nmInit()`, `nmLoad()`, `nmRender()` (nm = new menu)
- **ID 접두사 사용**: 새 기능의 모든 HTML 요소 ID에 고유한 접두사 사용
  - 예: `swContainer`, `swButton`, `swTable`
- **CSS 클래스 접두사 사용**: 새 기능의 모든 CSS 클래스에 고유한 접두사 사용
  - 예: `.sw-container`, `.sw-button`, `.sw-table`

### ✅ 작업 후 필수 확인

#### 1. Git Diff 확인
```bash
# 기존 파일이 수정되지 않았는지 확인
git diff dashboard_server.html
git diff app.py
git diff api/*/routes_db.py
```
- **기존 파일에 변경사항이 있으면 안 됨**
- 변경사항이 있으면 즉시 되돌리기

#### 2. 기존 기능 테스트
- [ ] 로그인 기능 정상 작동
- [ ] 반품 등록/조회 정상 작동
- [ ] 기존 메뉴들이 정상 작동
- [ ] 모바일 페이지 정상 작동
- [ ] F5 새로고침 시 메뉴 유지 기능 정상 작동

#### 3. 새 기능 테스트
- [ ] 새 메뉴가 정상적으로 표시되는지 확인
- [ ] 새 기능이 정상적으로 작동하는지 확인
- [ ] 새 기능이 기존 기능에 영향을 주지 않는지 확인

### 🚨 문제 발생 시 대응

#### 1. 기존 기능이 작동하지 않는 경우
- **즉시 롤백**:
  ```bash
  git reset --hard HEAD~1
  ```
- **원인 분석**: 어떤 파일을 수정했는지 확인
- **재작업**: 기존 파일을 수정하지 않는 방법으로 재구현

#### 2. 충돌이 발생한 경우
- **ID 충돌**: 새로운 ID로 변경
- **함수명 충돌**: 새로운 함수명으로 변경
- **CSS 클래스명 충돌**: 새로운 클래스명으로 변경

### 📚 참고 예시

#### ✅ 올바른 예시: 특수작업 메뉴 추가 (모듈화)
- `special_works.html` 파일 생성 (별도 파일)
- `api/special_works/routes_db.py` 파일 생성 (새 디렉토리)
- `dashboard_server.html`에 메뉴 버튼만 추가
- `app.py`에 blueprint 등록만 추가
- 모든 함수에 `sw` 접두사 사용 (`swInit()`, `swLoad()` 등)
- 모든 ID에 `sw` 접두사 사용 (`swContainer`, `swButton` 등)

#### ❌ 잘못된 예시: 기존 코드 수정
- `dashboard_server.html`의 기존 함수 수정
- `app.py`의 기존 라우트 수정
- 기존 HTML 요소 수정
- 기존 JavaScript 함수 수정

### 🔍 디버깅 팁

#### 기존 기능이 작동하지 않는 경우
1. **Git Diff로 확인**: 어떤 파일이 수정되었는지 확인
2. **수정된 파일 되돌리기**: `git restore <파일명>`
3. **기존 기능만 테스트**: 새 기능을 제외하고 기존 기능만 테스트
4. **단계별 롤백**: 최근 커밋부터 하나씩 되돌리며 문제 원인 찾기

#### 새 기능이 작동하지 않는 경우
1. **콘솔 로그 확인**: JavaScript 오류 확인
2. **네트워크 탭 확인**: API 호출 확인
3. **요소 존재 확인**: `document.getElementById()`로 요소 찾기
4. **충돌 확인**: ID/함수명 충돌 확인

---

## 📘 새로운 모듈 메뉴 만들기 가이드 (2025-11-20 추가)

### 🎯 개요
새로운 모듈 메뉴를 만들 때 관리자와 화주사를 구분하고, 각 모드에 맞는 리스트를 불러오는 방법을 정리한 가이드입니다.
**특수작업 메뉴(`special_works.html`)를 참고 예시로 사용하세요.**

### 📋 필수 구조

#### 1. 파일 구조
```
새로운_메뉴.html          # 프론트엔드 (HTML, CSS, JavaScript)
api/새로운_메뉴/
  __init__.py           # Blueprint export
  routes_db.py          # API 라우트 (백엔드)
```

#### 2. 네이밍 규칙
- **접두사 사용**: 모든 함수, ID, CSS 클래스에 고유한 접두사 사용
  - 예: 특수작업 → `sw` (special works)
  - 예: 새 메뉴 → `nm` (new menu)
- **함수명 패턴**:
  - 공통: `{prefix}CommonInit()`, `{prefix}ApplyVisibility()`, `{prefix}GetUserHeaders()`
  - 관리자: `{prefix}AdminInit()`, `{prefix}AdminLoadList()`, `{prefix}AdminRenderList()`
  - 화주사: `{prefix}ConsignorInit()`, `{prefix}ConsignorLoadList()`, `{prefix}ConsignorRenderList()`
- **ID 패턴**: `{prefix}Container`, `{prefix}AdminSection`, `{prefix}ConsignorSection`
- **CSS 클래스 패턴**: `.{prefix}-admin-only`, `.{prefix}-consignor-only`

### 🔑 1단계: 역할 감지 (프론트엔드)

#### 방법 1: 헤더에서 역할 정보 가져오기 (권장)
```javascript
// 가장 확실한 방법 - 헤더의 companyInfo 요소 확인
const companyInfoEl = document.getElementById('companyInfo');
if (companyInfoEl && companyInfoEl.textContent) {
  const headerText = companyInfoEl.textContent.trim();
  // "[관리자]"가 포함되어 있으면 관리자
  if (headerText.includes('[관리자]')) {
    {prefix}CurrentRole = '관리자';
    // username 추출: "관리자 [관리자] (username)" 형식
    const usernameMatch = headerText.match(/\(([^)]+)\)/);
    if (usernameMatch) {
      {prefix}CurrentUsername = usernameMatch[1].trim();
    }
    // 회사명 추출: "[관리자]" 앞의 텍스트
    const companyMatch = headerText.match(/^([^[]+)/);
    if (companyMatch) {
      {prefix}CurrentCompany = companyMatch[1].trim();
    }
  } else {
    // 화주사 모드: "화주사명 (username)" 형식
    const usernameMatch = headerText.match(/\(([^)]+)\)/);
    if (usernameMatch) {
      {prefix}CurrentUsername = usernameMatch[1].trim();
    }
    const companyMatch = headerText.match(/^([^(]+)/);
    if (companyMatch) {
      {prefix}CurrentCompany = companyMatch[1].trim();
    }
    {prefix}CurrentRole = '화주사';
  }
}
```

#### 방법 2: 전역 변수 또는 localStorage (백업)
```javascript
// 헤더 정보가 없으면 기존 방식 사용
{prefix}CurrentRole = (window.currentRole || localStorage.getItem('client_role') || '').toString().trim();
{prefix}CurrentCompany = (window.currentCompany || localStorage.getItem('client_company') || '').toString().trim();
{prefix}CurrentUsername = (window.currentUsername || localStorage.getItem('client_username') || '').toString().trim();
```

#### 역할 확인 로직
```javascript
// 역할 확인을 엄격하게 (공백 제거)
const roleNormalized = {prefix}CurrentRole.toString().trim();
const isAdmin = (roleNormalized === '관리자');

// 모드별 초기화 함수 호출
if (isAdmin) {
  {prefix}AdminInit();
} else {
  {prefix}ConsignorInit();
}
```

### 🎨 2단계: 가시성 제어 (CSS + JavaScript)

#### HTML 구조
```html
<div id="{prefix}Container">
  <!-- 관리자 전용 섹션 -->
  <div id="{prefix}AdminSection" class="{prefix}-admin-only">
    <!-- 관리자 전용 내용 -->
  </div>
  
  <!-- 화주사 전용 섹션 -->
  <div id="{prefix}ConsignorSection" class="{prefix}-consignor-only">
    <!-- 화주사 전용 내용 -->
  </div>
  
  <!-- 공통 섹션 -->
  <div id="{prefix}CommonSection">
    <!-- 공통 내용 -->
  </div>
</div>
```

#### CSS 스타일
```css
/* 관리자 전용 섹션 (기본 숨김) */
.{prefix}-admin-only {
  display: none;
}

/* 화주사 전용 섹션 (기본 숨김) */
.{prefix}-consignor-only {
  display: none;
}
```

#### JavaScript 가시성 제어 함수
```javascript
function {prefix}ApplyVisibility() {
  const container = document.getElementById('{prefix}Container');
  if (!container) return;
  
  const roleNormalized = ({prefix}CurrentRole || '').toString().trim();
  const isAdmin = (roleNormalized === '관리자');
  
  // 관리자 섹션 표시/숨김
  container.querySelectorAll('.{prefix}-admin-only').forEach(el => {
    el.style.display = isAdmin ? 'block' : 'none';
  });
  
  // 화주사 섹션 표시/숨김
  container.querySelectorAll('.{prefix}-consignor-only').forEach(el => {
    el.style.display = isAdmin ? 'none' : 'block';
  });
}
```

### 🔽 2-1단계: 검색형 드롭다운 표준 (2025-11-20 추가)

- **모든 신규/개선 드롭다운은 “검색 가능한 드롭다운(typeahead)” 방식으로 구현한다.**
  - 기존 단순 `<select>`를 유지해야 하는 경우에도, 작업 범위 안에 해당 드롭다운이 있다면 검색형 구조로 교체한다.
  - 예외는 모바일 네이티브 셀렉터 등 운영체제가 제공하는 UI를 반드시 사용해야 하는 경우뿐이며, 반드시 작업 전 사용자에게 확인한다.
- **구조**
  ```html
  <div class="{prefix}-searchable-select">
    <input type="text"
           id="{prefix}CompanyInput"
           class="{prefix}-form-input"
           placeholder="항목을 입력하거나 선택하세요"
           autocomplete="off">
    <input type="hidden" id="{prefix}CompanyValue">
    <div id="{prefix}CompanyDropdown" class="{prefix}-dropdown-list"></div>
  </div>
  ```
- **필수 스타일 속성**
  ```css
  .{prefix}-searchable-select { position: relative; width: 100%; }
  .{prefix}-dropdown-list {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background: #fff;
    border: 2px solid #ffeaa7;
    border-radius: 8px;
    max-height: 220px;
    overflow-y: auto;
    z-index: 1000;
    display: none;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  }
  .{prefix}-dropdown-list.show { display: block; }
  .{prefix}-dropdown-item {
    padding: 10px 15px;
    cursor: pointer;
    border-bottom: 1px solid #f0f0f0;
    transition: background-color 0.2s;
  }
  .{prefix}-dropdown-item:hover,
  .{prefix}-dropdown-item.highlight {
    background: #fff3d4;
  }
  ```
- **필수 JavaScript 패턴**
  ```javascript
  function {prefix}InitSearchableDropdown({ inputId, hiddenId, dropdownId, items }) {
    const inputEl = document.getElementById(inputId);
    const hiddenEl = document.getElementById(hiddenId);
    const dropdownEl = document.getElementById(dropdownId);
    if (!inputEl || !hiddenEl || !dropdownEl) return;

    let isOpen = false;
    let closeTimeout = null;

    const renderList = (keyword = '') => {
      const filtered = items.filter(item =>
        item.toLowerCase().includes(keyword.toLowerCase())
      );
      dropdownEl.innerHTML = filtered.length
        ? filtered.map(name => `<div class="{prefix}-dropdown-item" data-value="${name}">${name}</div>`).join('')
        : '<div class="{prefix}-dropdown-item" style="color:#999;cursor:default;">검색 결과가 없습니다</div>';
    };

    const openDropdown = () => {
      clearTimeout(closeTimeout);
      renderList(inputEl.value);
      dropdownEl.classList.add('show');
      isOpen = true;
    };

    const scheduleClose = () => {
      clearTimeout(closeTimeout);
      closeTimeout = setTimeout(() => {
        dropdownEl.classList.remove('show');
        isOpen = false;
      }, 120);
    };

    inputEl.addEventListener('input', (e) => {
      hiddenEl.value = e.target.value;
      if (!isOpen) openDropdown();
      else renderList(e.target.value);
    });

    ['focus', 'click'].forEach(evt =>
      inputEl.addEventListener(evt, () => {
        clearTimeout(closeTimeout);
        openDropdown();
      })
    );

    dropdownEl.addEventListener('click', (e) => {
      const item = e.target.closest('.{prefix}-dropdown-item');
      if (!item || !item.dataset.value) return;
      inputEl.value = item.dataset.value;
      hiddenEl.value = item.dataset.value;
      dropdownEl.classList.remove('show');
      isOpen = false;
    });

    document.addEventListener('mousedown', (e) => {
      if (!inputEl.contains(e.target) && !dropdownEl.contains(e.target)) {
        scheduleClose();
      }
    });
  }
  ```
- **체크리스트**
  - [ ] 입력 시 실시간 필터링 (대소문자 무관)
  - [ ] 외부 클릭 시 자연스럽게 닫힘 (깜빡임 금지)
  - [ ] hidden input에 최종 값 동기화 (폼 제출용)
  - [ ] 중복 이벤트 리스너 방지 (초기화 시 기존 리스너 제거)
  - [ ] 접근성 고려: 키보드 탭 이동 시에도 열리고 선택 가능해야 함
  - [ ] API 연동 시 목록 데이터가 없는 경우 사용자 안내 문구 출력
  - [ ] 동일 페이지 내 여러 검색형 드롭다운 동시 사용 가능하도록 네임스페이스 분리
  - [ ] 기존 `<select>`는 백업 용도로만 유지 (예: 브라우저 미지원 대응), display:none 처리 금지

> ✅ `special_works.html`의 화주사 선택 드롭다운을 **유일한 표준 참고 예시**로 삼는다. 신규 메뉴에서 다른 구현 방식을 사용하면 코드 리뷰에서 즉시 반려한다.

### 📊 3단계: 리스트 불러오기

#### 관리자 모드 리스트 로드
```javascript
function {prefix}AdminLoadList() {
  const container = document.getElementById('{prefix}Container');
  if (!container) return;
  
  // 1. 필터 값 수집 (관리자 전용 필터)
  const startDate = container.querySelector('#{prefix}AdminFilterStartDate')?.value || '';
  const endDate = container.querySelector('#{prefix}AdminFilterEndDate')?.value || '';
  const filterCompany = container.querySelector('#{prefix}AdminFilterCompany')?.value || '';
  
  // 2. 날짜가 비어있으면 오늘 날짜로 설정 (선택사항)
  const today = new Date().toISOString().split('T')[0];
  const finalStartDate = startDate || today;
  const finalEndDate = endDate || today;
  
  // 3. API URL 구성
  let url = '/api/{prefix}/list?';
  if (finalStartDate) url += `start_date=${finalStartDate}&`;
  if (finalEndDate) url += `end_date=${finalEndDate}&`;
  if (filterCompany) url += `company_name=${encodeURIComponent(filterCompany)}&`;
  
  // 4. 로딩 표시
  const tbody = container.querySelector('#{prefix}TableBody');
  if (tbody) tbody.innerHTML = '<tr><td colspan="10" class="no-data">로딩 중...</td></tr>';
  
  // 5. API 호출
  fetch(url, {
    credentials: 'include',
    headers: {prefix}GetUserHeaders()
  })
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        let items = data.data || [];
        // 날짜 내림차순 정렬 (최근 항목 먼저)
        items.sort((a, b) => new Date(b.date) - new Date(a.date));
        // 관리자 전용 렌더링
        {prefix}AdminRenderList(items);
      } else {
        if (tbody) tbody.innerHTML = `<tr><td colspan="10" class="no-data">${data.message || '목록을 불러오는 중 오류가 발생했습니다.'}</td></tr>`;
      }
    })
    .catch(error => {
      console.error('[{PREFIX}] 관리자 목록 로드 오류:', error);
      if (tbody) tbody.innerHTML = '<tr><td colspan="10" class="no-data">목록을 불러오는 중 오류가 발생했습니다.</td></tr>';
    });
}
```

#### 화주사 모드 리스트 로드
```javascript
function {prefix}ConsignorLoadList() {
  const container = document.getElementById('{prefix}Container');
  if (!container) return;
  
  // 1. 필터 값 수집 (화주사 전용 필터)
  const monthValue = container.querySelector('#{prefix}ConsignorFilterMonth')?.value || '';
  
  // 2. 월을 날짜 범위로 변환
  let startDate = '';
  let endDate = '';
  if (monthValue) {
    const [yearStr, monthStr] = monthValue.split('-');
    const year = parseInt(yearStr, 10);
    const month = parseInt(monthStr, 10);
    const lastDay = new Date(year, month, 0).getDate();
    const paddedMonth = monthStr.padStart(2, '0');
    startDate = `${yearStr}-${paddedMonth}-01`;
    endDate = `${yearStr}-${paddedMonth}-${String(lastDay).padStart(2, '0')}`;
  }
  
  // 3. 화주사명 확인 (필수)
  const companyName = {prefix}CurrentCompany;
  if (!companyName) {
    console.error('[{PREFIX}] 화주사 정보를 확인할 수 없습니다');
    alert('화주사 정보를 확인할 수 없습니다.');
    return;
  }
  
  // 4. API URL 구성
  let url = '/api/{prefix}/list?';
  if (startDate) url += `start_date=${startDate}&`;
  if (endDate) url += `end_date=${endDate}&`;
  url += `company_name=${encodeURIComponent(companyName)}&`;
  
  // 5. 로딩 표시
  const tbody = container.querySelector('#{prefix}TableBody');
  if (tbody) tbody.innerHTML = '<tr><td colspan="9" class="no-data">로딩 중...</td></tr>';
  
  // 6. API 호출
  fetch(url, {
    credentials: 'include',
    headers: {prefix}GetUserHeaders()
  })
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        let items = data.data || [];
        // 날짜 내림차순 정렬 (최근 항목 먼저)
        items.sort((a, b) => new Date(b.date) - new Date(a.date));
        // 화주사 전용 렌더링
        {prefix}ConsignorRenderList(items);
      } else {
        if (tbody) tbody.innerHTML = `<tr><td colspan="9" class="no-data">${data.message || '목록을 불러오는 중 오류가 발생했습니다.'}</td></tr>`;
      }
    })
    .catch(error => {
      console.error('[{PREFIX}] 화주사 목록 로드 오류:', error);
      if (tbody) tbody.innerHTML = '<tr><td colspan="9" class="no-data">목록을 불러오는 중 오류가 발생했습니다.</td></tr>';
    });
}
```

### 🔌 4단계: API 헤더 전달 (프론트엔드 → 백엔드)

#### 프론트엔드: 헤더 생성 함수
```javascript
function {prefix}GetUserHeaders() {
  const encodeHeader = (value) => encodeURIComponent((value || '').toString().trim());
  return {
    'X-User-Role': encodeHeader({prefix}CurrentRole),
    'X-User-Name': encodeHeader({prefix}CurrentUsername),
    'X-Company-Name': encodeHeader({prefix}CurrentCompany)
  };
}
```

#### 백엔드: 헤더에서 역할 정보 추출
```python
def get_user_context():
    """사용자 컨텍스트 가져오기 (헤더 또는 세션)"""
    from urllib.parse import unquote
    
    # 헤더에서 사용자 정보 가져오기
    role = request.headers.get('X-User-Role', '').strip()
    username = request.headers.get('X-User-Name', '').strip()
    company_name = request.headers.get('X-Company-Name', '').strip()
    
    # URL 디코딩
    if role:
        role = unquote(role)
    if username:
        username = unquote(username)
    if company_name:
        company_name = unquote(company_name)
    
    return {
        'role': role or '화주사',
        'username': username,
        'company_name': company_name
    }

# API 엔드포인트에서 사용
@new_menu_bp.route('/list', methods=['GET'])
def get_list():
    try:
        user_context = get_user_context()
        role = user_context['role']
        company_name = user_context['company_name']
        
        # 화주사는 자신의 데이터만 조회
        if role != '관리자':
            if not company_name:
                return jsonify({
                    'success': False,
                    'data': [],
                    'message': '화주사 정보를 확인할 수 없습니다.'
                }), 400
            # 화주사 필터 적용
            filter_company_name = company_name
        
        # 관리자는 모든 데이터 조회 가능
        # ... 데이터 조회 로직 ...
```

### 🔄 5단계: 초기화 흐름

#### 공통 초기화 함수
```javascript
// 전역 변수
var {prefix}CurrentRole = '';
var {prefix}CurrentCompany = '';
var {prefix}CurrentUsername = '';
var {prefix}Initialized = false;

// 공통 초기화 함수
function {prefix}CommonInit() {
  if ({prefix}Initialized) {
    console.log('[{PREFIX}] 이미 초기화됨, 중복 실행 방지');
    return;
  }
  
  const container = document.getElementById('{prefix}Container');
  if (!container) {
    console.error('[{PREFIX}] {prefix}Container를 찾을 수 없습니다');
    return;
  }
  
  // 1. 역할 확인 (헤더 우선, 없으면 전역 변수/localStorage)
  // ... 역할 감지 로직 ...
  
  // 2. 가시성 제어 (먼저 실행하여 섹션 표시)
  {prefix}ApplyVisibility();
  
  // 3. 모드별 초기화 함수 호출
  const roleNormalized = {prefix}CurrentRole.toString().trim();
  const isAdmin = (roleNormalized === '관리자');
  
  if (isAdmin) {
    {prefix}AdminInit();
  } else {
    {prefix}ConsignorInit();
  }
  
  // 4. 가시성 제어 재실행 (초기화 후 다시 확인)
  setTimeout(() => {
    {prefix}ApplyVisibility();
  }, 50);
  
  {prefix}Initialized = true;
  console.log('[{PREFIX}] 초기화 완료');
}
```

#### 관리자 초기화 함수
```javascript
function {prefix}AdminInit() {
  console.log('[{PREFIX}] {prefix}AdminInit 시작');
  const container = document.getElementById('{prefix}Container');
  if (!container) return;
  
  // 1. 날짜 필터 초기화 (오늘 날짜)
  const today = new Date().toISOString().split('T')[0];
  const startDate = container.querySelector('#{prefix}AdminFilterStartDate');
  const endDate = container.querySelector('#{prefix}AdminFilterEndDate');
  if (startDate) startDate.value = today;
  if (endDate) endDate.value = today;
  
  // 2. 필요한 데이터 로드 (예: 화주사 목록)
  {prefix}AdminLoadCompanies();
  
  // 3. 리스트 로드
  {prefix}AdminLoadList();
}
```

#### 화주사 초기화 함수
```javascript
function {prefix}ConsignorInit() {
  console.log('[{PREFIX}] {prefix}ConsignorInit 시작');
  const container = document.getElementById('{prefix}Container');
  if (!container) return;
  
  // 1. 월 필터 초기화 (오늘 월)
  const today = new Date().toISOString().split('T')[0];
  const monthInput = container.querySelector('#{prefix}ConsignorFilterMonth');
  if (monthInput) monthInput.value = today.slice(0, 7); // YYYY-MM
  
  // 2. 리스트 로드
  {prefix}ConsignorLoadList();
}
```

### ✅ 체크리스트 (새 모듈 메뉴 추가 시)

#### 프론트엔드 체크리스트
- [ ] 접두사(`{prefix}`)를 모든 함수, ID, CSS 클래스에 사용
- [ ] 역할 감지 로직 구현 (헤더 우선, 전역 변수/localStorage 백업)
- [ ] 가시성 제어 함수 구현 (`{prefix}ApplyVisibility()`)
- [ ] CSS 클래스 `.{prefix}-admin-only`, `.{prefix}-consignor-only` 정의
- [ ] 공통 초기화 함수 구현 (`{prefix}CommonInit()`)
- [ ] 관리자 초기화 함수 구현 (`{prefix}AdminInit()`)
- [ ] 화주사 초기화 함수 구현 (`{prefix}ConsignorInit()`)
- [ ] 관리자 리스트 로드 함수 구현 (`{prefix}AdminLoadList()`)
- [ ] 화주사 리스트 로드 함수 구현 (`{prefix}ConsignorLoadList()`)
- [ ] 헤더 생성 함수 구현 (`{prefix}GetUserHeaders()`)
- [ ] 관리자 모드에서 화주사 함수 호출 방지 (역할 체크)
- [ ] 화주사 모드에서 관리자 함수 호출 방지 (역할 체크)

#### 백엔드 체크리스트
- [ ] `get_user_context()` 함수 구현 (헤더에서 역할 정보 추출)
- [ ] API 엔드포인트에서 `get_user_context()` 사용
- [ ] 화주사 모드: `company_name` 필터 적용 (자신의 데이터만 조회)
- [ ] 관리자 모드: 모든 데이터 조회 가능
- [ ] SQLite/PostgreSQL 호환성 확인 (`cursor_factory` 사용 시 조건부 처리)

#### 통합 체크리스트
- [ ] `dashboard_server.html`에 메뉴 버튼 추가
- [ ] `switchMenu()` 또는 `switchAdminTab()` 함수에 새 메뉴 처리 추가
- [ ] `validTabs` 또는 `validMenus` 배열에 새 메뉴 이름 추가
- [ ] `localStorage` 저장/복원 로직 확인 (F5 새로고침 시 메뉴 유지)
- [ ] `app.py`에 Blueprint 등록
- [ ] `load{NewMenu}Content()` 함수 구현 (AJAX로 HTML 로드)

### 📚 참고 예시: 특수작업 메뉴
- **파일**: `special_works.html`, `api/special_works/routes_db.py`
- **접두사**: `sw` (special works)
- **구조**: 위의 모든 패턴을 따름
- **특징**:
  - 헤더에서 역할 정보 추출
  - 관리자/화주사 모드 분리
  - 각 모드별 리스트 로드 함수 분리
  - API 헤더로 역할 정보 전달

### ⚠️ 주의사항

1. **역할 감지 순서**:
   - 1순위: 헤더의 `companyInfo` 요소 (가장 확실)
   - 2순위: `window.currentRole` (전역 변수)
   - 3순위: `localStorage.getItem('client_role')`

2. **가시성 제어**:
   - CSS에서 기본값 `display: none` 설정
   - JavaScript에서 `display: 'block'` 또는 `'none'` 명시적 설정
   - 빈 문자열(`''`) 사용 금지 (CSS 기본값 사용 시 문제 발생 가능)

3. **리스트 로드 타이밍**:
   - 초기화 함수에서 자동 호출
   - 필터 변경 시 수동 호출
   - 로딩 표시 필수 (사용자 경험 개선)

4. **API 호출**:
   - 모든 API 호출에 `{prefix}GetUserHeaders()` 사용
   - `credentials: 'include'` 필수 (세션 쿠키 전달)
   - 에러 처리 필수 (네트워크 오류 포함)

5. **중복 초기화 방지**:
   - `{prefix}Initialized` 플래그 사용
   - 초기화 함수 시작 부분에서 체크

---

